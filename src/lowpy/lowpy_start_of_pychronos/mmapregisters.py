

FPGA_const_dict = {
	"DISPLAY_CTL_ADDRESS_SEL_OFFSET" :		0,
	"DISPLAY_CTL_SCALER_NN_OFFSET" :		1,
	"DISPLAY_CTL_SYNC_INH_OFFSET" :			2,
	"DISPLAY_CTL_READOUT_INH_OFFSET" :		3,
	"DISPLAY_CTL_COLOR_MODE_OFFSET" :		4,
	"DISPLAY_CTL_FOCUS_PEAK_EN_OFFSET" :	5,
	"DISPLAY_CTL_FOCUS_PEAK_COLOR_OFFSET" :	6,
	"DISPLAY_CTL_ZEBRA_EN_OFFSET" :			9,

	"RAM_REG_BASE" :						0x2000,
}

FPGA_dict = {
	"SENSOR_CONTROL" :				0x0,        #0,		#0x00
	"SENSOR_CLK_PHASE" :			0x4,     #2,		#0x04
	"SENSOR_SYNC_TOKEN" :			0x8,        #4,		#0x08
	"SENSOR_DATA_CORRECT" :			0xc,      #6,		#0x0c
	"SENSOR_FIFO_START_W_THRESH" :	0x10,     #8,		#0x10	
	"SENSOR_FIFO_STOP_W_THRESH" :	0x14,      #10,		#0x14
	"IMAGER_FRAME_PERIOD" :			0x1c,      #14,		#0x1c
	"IMAGER_INT_TIME" :				0x20,     #16,		#0x20
	"SENSOR_SCI_CONTROL" :			0x24,       #18,		#0x24
	"SENSOR_SCI_ADDRESS" :			0x28,       #20,		#0x28
	"SENSOR_SCI_DATALEN" :			0x2c,       #22,		#0x2c
	"SENSOR_SCI_FIFO_WR_ADDR" :		0x30,       #24,		#0x30
	"SENSOR_SCI_READ_DATA" :		0x34,      #26,		#0x34

	#"SYSTEM_RESET" :				0x300,

	"SEQ_CTL" :						0x40,       #32,
	"SEQ_STATUS" :					0x44,     #34,
	"SEQ_FRAME_SIZE" :				0x48,      #36,
	"SEQ_REC_REGION_START" :		0x4c,      #38,
	"SEQ_REC_REGION_END" :			0x50,       #40,
	"SEQ_LIVE_ADDR_0" :				0x54,     #42,
	"SEQ_LIVE_ADDR_1" :				0x58,     #44,
	"SEQ_LIVE_ADDR_2" :				0x5c,     #46,
	"SEQ_TRIG_DELAY" :				0x60,      #48,
	"SEQ_MD_FIFO_READ" :			0x64,     #50,

	"SENSOR_MAGIC_START_DELAY" :	0x68,       #52,
	"SENSOR_LINE_PERIOD" :			0x6c,       #54,

	"TRIG_ENABLE" :					0xa0,        #0x50,
	"TRIG_INVERT" :					0xa4,        #0x52,
	"TRIG_DEBOUNCE" :				0xa8,       #0x54,

	"IO_OUT_LEVEL" :				0xac,        #0x56,
	"IO_OUT_SOURCE" :				0xb0,       #0x58,
	"IO_OUT_INVERT" :				0xb4,       #0x5A,
	"IO_IN" :						0xb8,     #0x5C,
	"EXT_SHUTTER_CTL" :				0xbc,     #0x5E,

	"SEQ_PGM_MEM_START" :			0x100,        #0x80,
	"GPMC_PAGE_OFFSET" :			0x200,     #0x100,

	"DISPLAY_CTL" :					0x400,        #0x200,
	"DISPLAY_FRAME_ADDRESS" :		0x404,     #0x202,
	"DISPLAY_FPN_ADDRESS" :			0x408,      #0x204,
	"DISPLAY_GAIN" :				0x40c,        #0x206,
	"DISPLAY_H_PERIOD" :			0x410,     #0x208,
	"DISPLAY_V_PERIOD" :			0x414,     #0x20A,
	"DISPLAY_H_SYNC_LEN" :			0x418,       #0x20C,
	"DISPLAY_V_SYNC_LEN" :			0x41c,       #0x20E,
	"DISPLAY_H_BACK_PORCH" :		0x420,      #0x210,
	"DISPLAY_V_BACK_PORCH" :		0x424,      #0x212,
	"DISPLAY_H_RES" :				0x428,       #0x214,
	"DISPLAY_V_RES" :				0x42c,       #0x216,
	"DISPLAY_H_OUT_RES" :			0x430,        #0x218,
	"DISPLAY_V_OUT_RES" :			0x440,        #0x220,
	"DISPLAY_PEAKING_THRESH" :		0x444,        #0x222,
	"DISPLAY_PIPELINE" :			0x448,     #0x224,
	"DISPLAY_MANUAL_SYNC" :			0x450,      #0x228,

	"CCM_11" :						0x4c0,        #0x260,
	"CCM_12" :						0x4c4,        #0x262,
	"CCM_13" :						0x4c8,        #0x264,
	"CCM_21" :						0x4d0,        #0x268,
	"CCM_22" :						0x4d4,        #0x26A,
	"CCM_23" :						0x4d8,        #0x26C,
	"CCM_31" :						0x4dc,        #0x26E,
	"CCM_32" :						0x4e0,        #0x270,
	"CCM_33" :						0x4e4,        #0x272,
	"WL_DYNDLY_0" :					0x4e8,        #0x274,
	"WL_DYNDLY_1" :					0x4ec,        #0x276,
	"WL_DYNDLY_2" :					0x4f0,        #0x278,
	"WL_DYNDLY_3" :					0x4f4,        #0x27A,

	"MMU_CONFIG_ADDRESS" :			0x520,       #0x290,

	"SYSTEM_RESET" :				0x600,        #0x300,
	"FPGA_VERSION" :				0x604,        #0x302,
	"FPGA_SUBVERSION" :				0x608,     #0x304,
	"DCG_MEM_START" :				0x1000,       #0x800,



                                      
#Image sensor control register
	"IMAGE_SENSOR_CONTROL" :				0,		# this used to have an _ADDR suffix,

	"IMAGE_SENSOR_RESET_MASK" :				0x1,
	"IMAGE_SENSOR_EVEN_TIMESLOT_MASK" :		0x2,

#Phase control register

 ### IMAGE_SENSOR_CLK_PHASE_ADDR		=	(SENSOR_CLK_PHASE * 2)
	"IMAGE_SENSOR_CLK_PHASE_OFFSET" :		0,

#Sync Token Register
 ### IMAGE_SENSOR_SYNC_TOKEN_ADDR	=	(SENSOR_SYNC_TOKEN * 2)

#Data Correct
#Indicates data channels 11:0 and sync are correct
# Format: data[11], data[10], ... data[0], sync

 ### IMAGE_SENSOR_DATA_CORRECT_ADDR	=	(SENSOR_DATA_CORRECT * 2)

#Image data write path FIFO thresholds for start and stop of data write to ram

 ### IMAGE_SENSOR_FIFO_START_W_THRESH_ADDR	=	(SENSOR_FIFO_START_W_THRESH	* 2)
 ### IMAGE_SENSOR_FIFO_STOP_W_THRESH_ADDR	=	(SENSOR_FIFO_STOP_W_THRESH * 2)

 ### IMAGER_FRAME_PERIOD_ADDR			=	(IMAGER_FRAME_PERIOD * 2)
 ### IMAGER_INT_TIME_ADDR				=	(IMAGER_INT_TIME * 2)

 ### SENSOR_SCI_CONTROL_ADDR				=	(SENSOR_SCI_CONTROL * 2)
	"SENSOR_SCI_CONTROL_RUN_MASK" :			0x1,						#Write 1 to start, reads 1 while busy, 0 when done,
	"SENSOR_SCI_CONTROL_RW_MASK" :			0x2,						#Read == 1, Write == 0,
	"SENSOR_SCI_CONTROL_FIFO_FULL_MASK" :	0x4,					#1 indicates FIFO is full,
 ### SENSOR_SCI_ADDRESS_ADDR				=	(SENSOR_SCI_ADDRESS * 2)
 ### SENSOR_SCI_DATALEN_ADDR				=	(SENSOR_SCI_DATALEN * 2)
 ### SENSOR_SCI_FIFO_WR_ADDR_ADDR		=	(SENSOR_SCI_FIFO_WR_ADDR * 2)
 ### SENSOR_SCI_READ_DATA_ADDR			=	(SENSOR_SCI_READ_DATA * 2)

 ### SEQ_CTL_ADDR					=	(SEQ_CTL * 2)
	"SEQ_CTL_SW_TRIG_MASK" :				0x1,
	"SEQ_CTL_START_REC_MASK" :				0x2,
	"SEQ_CTL_STOP_REC_MASK" :				0x4,
	"SEQ_CTL_TRIG_DELAY_MODE_MASK" :		0x8,

 ### SEQ_STATUS_ADDR					=	(SEQ_STATUS * 2)
	"SEQ_STATUS_RECORDING_MASK" :			0x1,
	"SEQ_STATUS_MD_FIFO_EMPTY_MASK" :		0x2,

 ### SEQ_FRAME_SIZE_ADDR				=	(SEQ_FRAME_SIZE * 2)
 ### SEQ_REC_REGION_START_ADDR		=	(SEQ_REC_REGION_START * 2)
 ### SEQ_REC_REGION_END_ADDR			=	(SEQ_REC_REGION_END * 2)
 ### SEQ_LIVE_ADDR_0_ADDR			=	(SEQ_LIVE_ADDR_0 * 2)
 ### SEQ_LIVE_ADDR_1_ADDR			=	(SEQ_LIVE_ADDR_1 * 2)
 ### SEQ_LIVE_ADDR_2_ADDR			=	(SEQ_LIVE_ADDR_2 * 2)
 ### SEQ_TRIG_DELAY_ADDR				=	(SEQ_TRIG_DELAY * 2)
 ### SEQ_MD_FIFO_READ_ADDR			=	(SEQ_MD_FIFO_READ * 2)
 ### SEQ_PGM_MEM_START_ADDR			=	(SEQ_PGM_MEM_START * 2)

 ### SENSOR_MAGIC_START_DELAY_ADDR	=	(SENSOR_MAGIC_START_DELAY * 2)
 ### SENSOR_LINE_PERIOD_ADDR			=	(SENSOR_LINE_PERIOD * 2)

 ### TRIG_ENABLE_ADDR				=	(TRIG_ENABLE * 2)
 ### TRIG_INVERT_ADDR				=	(TRIG_INVERT * 2)
 ### TRIG_DEBOUNCE_ADDR				=	(TRIG_DEBOUNCE * 2)

 ### IO_OUT_LEVEL_ADDR				=	(IO_OUT_LEVEL * 2)		#1 outputs high if selected (invert does not affect this)
 ### IO_OUT_SOURCE_ADDR				=	(IO_OUT_SOURCE * 2)		#1 selects int time, 0 selects IO_OUT_LEVEL
 ### IO_OUT_INVERT_ADDR				=	(IO_OUT_INVERT * 2)		#1 inverts int time signal
 ### IO_IN_ADDR						=	(IO_IN * 2)		#1 inverts int time signal

 ### EXT_SHUTTER_CTL_ADDR			=	(EXT_SHUTTER_CTL * 2)
	"EXT_SH_TRIGD_EXP_EN_MASK" :			0x1,
	"EXT_SH_TRIGD_EXP_EN_OFFSET" :			0,
	"EXT_SH_GATING_EN_MASK" :				0x2,
	"EXT_SH_GATING_EN_OFFSET" :				1,
	"EXT_SH_SRC_EN_MASK" :					0x1C,
	"EXT_SH_SRC_EN_OFFSET" :				2,

 ### GPMC_PAGE_OFFSET_ADDR			=	(GPMC_PAGE_OFFSET * 2)

 ### DISPLAY_CTL_ADDR				=	(DISPLAY_CTL * 2)
	"DISPLAY_CTL_ADDRESS_SEL_OFFSET" :		0,
	"DISPLAY_CTL_SCALER_NN_OFFSET" :		1,
	"DISPLAY_CTL_SYNC_INH_OFFSET" :			2,
	"DISPLAY_CTL_READOUT_INH_OFFSET" :		3,
	"DISPLAY_CTL_COLOR_MODE_OFFSET" :		4,
	"DISPLAY_CTL_FOCUS_PEAK_EN_OFFSET" :	5,
	"DISPLAY_CTL_FOCUS_PEAK_COLOR_OFFSET" :	6,
	"DISPLAY_CTL_ZEBRA_EN_OFFSET" :			9,

	"DISPLAY_CTL_ADDRESS_SEL_MASK" :		(1 << FPGA_const_dict["DISPLAY_CTL_ADDRESS_SEL_OFFSET"]),
	"DISPLAY_CTL_SCALER_NN_MASK" :			(1 << FPGA_const_dict["DISPLAY_CTL_SCALER_NN_OFFSET"]),
	"DISPLAY_CTL_SYNC_INH_MASK" :			(1 << FPGA_const_dict["DISPLAY_CTL_SYNC_INH_OFFSET"]),
	"DISPLAY_CTL_READOUT_INH_MASK" :		(1 << FPGA_const_dict["DISPLAY_CTL_READOUT_INH_OFFSET"]),
	"DISPLAY_CTL_COLOR_MODE_MASK" :			(1 << FPGA_const_dict["DISPLAY_CTL_COLOR_MODE_OFFSET"]),
	"DISPLAY_CTL_FOCUS_PEAK_EN_MASK" :		(1 << FPGA_const_dict["DISPLAY_CTL_FOCUS_PEAK_EN_OFFSET"]),
	"DISPLAY_CTL_FOCUS_PEAK_COLOR_MASK" :	(7 << FPGA_const_dict["DISPLAY_CTL_FOCUS_PEAK_COLOR_OFFSET"]),
	"DISPLAY_CTL_ZEBRA_EN_MASK" :			(1 << FPGA_const_dict["DISPLAY_CTL_ZEBRA_EN_OFFSET"]),

 ### DISPLAY_FRAME_ADDRESS_ADDR		=	(DISPLAY_FRAME_ADDRESS * 2)
 ### DISPLAY_FPN_ADDRESS_ADDR		=	(DISPLAY_FPN_ADDRESS * 2)
 ### DISPLAY_GAIN_ADDR				=	(DISPLAY_GAIN * 2)
 ### DISPLAY_H_PERIOD_ADDR			=	(DISPLAY_H_PERIOD * 2)
 ### DISPLAY_V_PERIOD_ADDR			=	(DISPLAY_V_PERIOD * 2)
 ### DISPLAY_H_SYNC_LEN_ADDR			=	(DISPLAY_H_SYNC_LEN * 2)
 ### DISPLAY_V_SYNC_LEN_ADDR			=	(DISPLAY_V_SYNC_LEN * 2)
 ### DISPLAY_H_BACK_PORCH_ADDR		=	(DISPLAY_H_BACK_PORCH * 2)
 ### DISPLAY_V_BACK_PORCH_ADDR		=	(DISPLAY_V_BACK_PORCH * 2)
 ### DISPLAY_H_RES_ADDR				=	(DISPLAY_H_RES * 2)
 ### DISPLAY_V_RES_ADDR				=	(DISPLAY_V_RES * 2)
 ### DISPLAY_H_OUT_RES_ADDR			=	(DISPLAY_H_OUT_RES * 2)
 ### DISPLAY_V_OUT_RES_ADDR			=	(DISPLAY_V_OUT_RES * 2)
 ### DISPLAY_PEAKING_THRESH_ADDR		=	(DISPLAY_PEAKING_THRESH * 2)

 ### DISPLAY_PIPELINE_ADDR           	=	(DISPLAY_PIPELINE * 2)
	"DISPLAY_PIPELINE_BIPASS_FPN" :			(1 << 0),
	"DISPLAY_PIPELINE_BIPASS_GAIN" :		(1 << 1),
	"DISPLAY_PIPELINE_BIPASS_DEMOSIAC" :	(1 << 2),
	"DISPLAY_PIPELINE_BIPASS_COLORMATRIX" :	(1 << 3),
	"DISPLAY_PIPELINE_BIPASS_GAMMA_TABLE" :	(1 << 4),
	"DISPLAY_PIPELINE_RAW_12BPP" :			(1 << 5),
	"DISPLAY_PIPELINE_RAW_16BPP" :			(1 << 6),
	"DISPLAY_PIPELINE_RAW_RIGHT_JUSTIFY" :	(1 << 7),
	"DISPLAY_PIPELINE_RAW_TEST_PATTERN" :	(1 << 15),

 ### DISPLAY_MANUAL_SYNC_ADDR        =	(DISPLAY_MANUAL_SYNC * 2)
	"DISPLAY_MANUAL_SYNC_MASK" :			(1),

 ### CCM_11_ADDR						=	(CCM_11 * 2)
 ### CCM_12_ADDR						=	(CCM_12 * 2)
 ### CCM_13_ADDR						=	(CCM_13 * 2)
 ### CCM_21_ADDR						=	(CCM_21 * 2)
 ### CCM_22_ADDR						=	(CCM_22 * 2)
 ### CCM_23_ADDR						=	(CCM_23 * 2)
 ### CCM_31_ADDR						=	(CCM_31 * 2)
 ### CCM_32_ADDR						=	(CCM_32 * 2)
 ### CCM_33_ADDR						=	(CCM_33 * 2)

 ### WL_DYNDLY_0_ADDR				=	(WL_DYNDLY_0 * 2)
 ### WL_DYNDLY_1_ADDR				=	(WL_DYNDLY_1 * 2)
 ### WL_DYNDLY_2_ADDR				=	(WL_DYNDLY_2 * 2)
 ### WL_DYNDLY_3_ADDR				=	(WL_DYNDLY_3 * 2)

 ### MMU_CONFIG_ADDR                 =	(MMU_CONFIG_ADDRESS * 2)
	"MMU_INVERT_CS" :			1,
	"MMU_SWITCH_STUFFED" :		2,

 ### SYSTEM_RESET_ADDR				=	(SYSTEM_RESET * 2)

 ### FPGA_VERSION_ADDR				=	(FPGA_VERSION * 2)
 ### FPGA_SUBVERSION_ADDR            =	(FPGA_SUBVERSION * 2)

 ### DCG_MEM_START_ADDR				=	(DCG_MEM_START * 2)



#========================================================================================================
#                                   New format registers

#---------------------------------- Wishbone RAM Access -----------------------------------------


	
	"RAM_REG_BLOCK" :			(FPGA_const_dict["RAM_REG_BASE"]),

# identifier
	"RAM_IDENTIFIER_REG" :			(FPGA_const_dict["RAM_REG_BASE"] + 0x00),
	"RAM_VERSION_REG" :			(FPGA_const_dict["RAM_REG_BASE"] + 0x04),
	"RAM_SUBVERSION_REG" :			(FPGA_const_dict["RAM_REG_BASE"] + 0x08),

# reset and control
	"RAM_CONTROL" :			(FPGA_const_dict["RAM_REG_BASE"] + 0x0C),
	"RAM_STATUS" :			(FPGA_const_dict["RAM_REG_BASE"] + 0x10),

	"RAM_ADDRESS" :			(FPGA_const_dict["RAM_REG_BASE"] + 0x20), # 32 bit ,
	"RAM_BURST_LENGTH" :			(FPGA_const_dict["RAM_REG_BASE"] + 0x24),

# Read/write buffers
	"RAM_BUFFER_START" :			(FPGA_const_dict["RAM_REG_BASE"] + 0x200), # 1024*16bit (64-ram page) ,
	"RAM_BUFFER_END" :			(FPGA_const_dict["RAM_REG_BASE"] + 0xA00),



	"RAM_IDENTIFIER" :			(0x0040),

	"RAM_CONTROL_TRIGGER_READ" :			0x0001,
	"RAM_CONTROL_TRIGGER_WRITE" :			0x0002,

	"RAM_BURST_LENGTH_MAX" :			32,



	}







#Register definitions from control register verilog file (in 16 bit word addresses)
SENSOR_CONTROL				=	0x0		#0x00
SENSOR_CLK_PHASE			=	0x4		#0x04
SENSOR_SYNC_TOKEN			=	0x8		#0x08
SENSOR_DATA_CORRECT			=	0xc		#0x0c
SENSOR_FIFO_START_W_THRESH	=	0x10		#0x10	
SENSOR_FIFO_STOP_W_THRESH	=	0x14		#0x14
IMAGER_FRAME_PERIOD			=	0x1c		#0x1c
IMAGER_INT_TIME				=	0x20		#0x20
SENSOR_SCI_CONTROL			=	0x24		#0x24
SENSOR_SCI_ADDRESS			=	0x28		#0x28
SENSOR_SCI_DATALEN			=	0x2c		#0x2c
SENSOR_SCI_FIFO_WR_ADDR		=	0x30		#0x30
SENSOR_SCI_READ_DATA		=	0x34		#0x34

SEQ_CTL						=	0x40
SEQ_STATUS					=	0x44
SEQ_FRAME_SIZE				=	0x48
SEQ_REC_REGION_START		=	0x4c
SEQ_REC_REGION_END			=	0x50
SEQ_LIVE_ADDR_0				=	0x54
SEQ_LIVE_ADDR_1				=	0x58
SEQ_LIVE_ADDR_2				=	0x5c
SEQ_TRIG_DELAY				=	0x60
SEQ_MD_FIFO_READ			=	0x64

SENSOR_MAGIC_START_DELAY	=	0x68
SENSOR_LINE_PERIOD			=	0x6c

TRIG_ENABLE					=	0xa0
TRIG_INVERT					=	0xa4
TRIG_DEBOUNCE				=	0xa8

IO_OUT_LEVEL				=	0xac
IO_OUT_SOURCE				=	0xb0
IO_OUT_INVERT				=	0xb4
IO_IN						=	0xb8
EXT_SHUTTER_CTL				=	0xbc

SEQ_PGM_MEM_START			=	0x100
GPMC_PAGE_OFFSET			=	0x200

DISPLAY_CTL					=	0x400
DISPLAY_FRAME_ADDRESS		=	0x404
DISPLAY_FPN_ADDRESS			=	0x408
DISPLAY_GAIN				=	0x40c
DISPLAY_H_PERIOD			=	0x410
DISPLAY_V_PERIOD			=	0x414
DISPLAY_H_SYNC_LEN			=	0x418
DISPLAY_V_SYNC_LEN			=	0x41c
DISPLAY_H_BACK_PORCH		=	0x420
DISPLAY_V_BACK_PORCH		=	0x424
DISPLAY_H_RES				=	0x428
DISPLAY_V_RES				=	0x42c
DISPLAY_H_OUT_RES			=	0x430
DISPLAY_V_OUT_RES			=	0x440
DISPLAY_PEAKING_THRESH		=	0x444
DISPLAY_PIPELINE            =	0x448
DISPLAY_MANUAL_SYNC         =	0x450

CCM_11						=	0x4c0
CCM_12						=	0x4c4
CCM_13						=	0x4c8
CCM_21						=	0x4d0
CCM_22						=	0x4d4
CCM_23						=	0x4d8
CCM_31						=	0x4dc
CCM_32						=	0x4e0
CCM_33						=	0x4e4
WL_DYNDLY_0					=	0x4e8
WL_DYNDLY_1					=	0x4ec
WL_DYNDLY_2					=	0x4f0
WL_DYNDLY_3					=	0x4f4

MMU_CONFIG_ADDRESS          =	0x520

SYSTEM_RESET				=	0x600
FPGA_VERSION				=	0x604
FPGA_SUBVERSION             =	0x608
DCG_MEM_START				=	0x1000



                                      
#Image sensor control register
IMAGE_SENSOR_CONTROL		=	0		# this used to have an _ADDR suffix

IMAGE_SENSOR_RESET_MASK			=	0x1
IMAGE_SENSOR_EVEN_TIMESLOT_MASK =	0x2

#Phase control register

 ### IMAGE_SENSOR_CLK_PHASE_ADDR		=	(SENSOR_CLK_PHASE * 2)
IMAGE_SENSOR_CLK_PHASE_OFFSET	=	0

#Sync Token Register
 ### IMAGE_SENSOR_SYNC_TOKEN_ADDR	=	(SENSOR_SYNC_TOKEN * 2)

#Data Correct
#Indicates data channels 11:0 and sync are correct
# Format: data[11], data[10], ... data[0], sync

 ### IMAGE_SENSOR_DATA_CORRECT_ADDR	=	(SENSOR_DATA_CORRECT * 2)

#Image data write path FIFO thresholds for start and stop of data write to ram

 ### IMAGE_SENSOR_FIFO_START_W_THRESH_ADDR	=	(SENSOR_FIFO_START_W_THRESH	* 2)
 ### IMAGE_SENSOR_FIFO_STOP_W_THRESH_ADDR	=	(SENSOR_FIFO_STOP_W_THRESH * 2)

 ### IMAGER_FRAME_PERIOD_ADDR			=	(IMAGER_FRAME_PERIOD * 2)
 ### IMAGER_INT_TIME_ADDR				=	(IMAGER_INT_TIME * 2)

 ### SENSOR_SCI_CONTROL_ADDR				=	(SENSOR_SCI_CONTROL * 2)
SENSOR_SCI_CONTROL_RUN_MASK			=	0x1						#Write 1 to start, reads 1 while busy, 0 when done
SENSOR_SCI_CONTROL_RW_MASK			=	0x2						#Read == 1, Write == 0
SENSOR_SCI_CONTROL_FIFO_FULL_MASK	=	0x4					#1 indicates FIFO is full
 ### SENSOR_SCI_ADDRESS_ADDR				=	(SENSOR_SCI_ADDRESS * 2)
 ### SENSOR_SCI_DATALEN_ADDR				=	(SENSOR_SCI_DATALEN * 2)
 ### SENSOR_SCI_FIFO_WR_ADDR_ADDR		=	(SENSOR_SCI_FIFO_WR_ADDR * 2)
 ### SENSOR_SCI_READ_DATA_ADDR			=	(SENSOR_SCI_READ_DATA * 2)

 ### SEQ_CTL_ADDR					=	(SEQ_CTL * 2)
SEQ_CTL_SW_TRIG_MASK			=	0x1
SEQ_CTL_START_REC_MASK			=	0x2
SEQ_CTL_STOP_REC_MASK			=	0x4
SEQ_CTL_TRIG_DELAY_MODE_MASK	=	0x8

 ### SEQ_STATUS_ADDR					=	(SEQ_STATUS * 2)
SEQ_STATUS_RECORDING_MASK		=	0x1
SEQ_STATUS_MD_FIFO_EMPTY_MASK	=	0x2

 ### SEQ_FRAME_SIZE_ADDR				=	(SEQ_FRAME_SIZE * 2)
 ### SEQ_REC_REGION_START_ADDR		=	(SEQ_REC_REGION_START * 2)
 ### SEQ_REC_REGION_END_ADDR			=	(SEQ_REC_REGION_END * 2)
 ### SEQ_LIVE_ADDR_0_ADDR			=	(SEQ_LIVE_ADDR_0 * 2)
 ### SEQ_LIVE_ADDR_1_ADDR			=	(SEQ_LIVE_ADDR_1 * 2)
 ### SEQ_LIVE_ADDR_2_ADDR			=	(SEQ_LIVE_ADDR_2 * 2)
 ### SEQ_TRIG_DELAY_ADDR				=	(SEQ_TRIG_DELAY * 2)
 ### SEQ_MD_FIFO_READ_ADDR			=	(SEQ_MD_FIFO_READ * 2)
 ### SEQ_PGM_MEM_START_ADDR			=	(SEQ_PGM_MEM_START * 2)

 ### SENSOR_MAGIC_START_DELAY_ADDR	=	(SENSOR_MAGIC_START_DELAY * 2)
 ### SENSOR_LINE_PERIOD_ADDR			=	(SENSOR_LINE_PERIOD * 2)

 ### TRIG_ENABLE_ADDR				=	(TRIG_ENABLE * 2)
 ### TRIG_INVERT_ADDR				=	(TRIG_INVERT * 2)
 ### TRIG_DEBOUNCE_ADDR				=	(TRIG_DEBOUNCE * 2)

 ### IO_OUT_LEVEL_ADDR				=	(IO_OUT_LEVEL * 2)		#1 outputs high if selected (invert does not affect this)
 ### IO_OUT_SOURCE_ADDR				=	(IO_OUT_SOURCE * 2)		#1 selects int time, 0 selects IO_OUT_LEVEL
 ### IO_OUT_INVERT_ADDR				=	(IO_OUT_INVERT * 2)		#1 inverts int time signal
 ### IO_IN_ADDR						=	(IO_IN * 2)		#1 inverts int time signal

 ### EXT_SHUTTER_CTL_ADDR			=	(EXT_SHUTTER_CTL * 2)
EXT_SH_TRIGD_EXP_EN_MASK		=	0x1
EXT_SH_TRIGD_EXP_EN_OFFSET		=	0
EXT_SH_GATING_EN_MASK			=	0x2
EXT_SH_GATING_EN_OFFSET			=	1
EXT_SH_SRC_EN_MASK				=	0x1C
EXT_SH_SRC_EN_OFFSET			=	2

 ### GPMC_PAGE_OFFSET_ADDR			=	(GPMC_PAGE_OFFSET * 2)

 ### DISPLAY_CTL_ADDR				=	(DISPLAY_CTL * 2)
DISPLAY_CTL_ADDRESS_SEL_OFFSET	=	0
DISPLAY_CTL_SCALER_NN_OFFSET	=	1
DISPLAY_CTL_SYNC_INH_OFFSET		=	2
DISPLAY_CTL_READOUT_INH_OFFSET	=	3
DISPLAY_CTL_COLOR_MODE_OFFSET	=	4
DISPLAY_CTL_FOCUS_PEAK_EN_OFFSET	=	5
DISPLAY_CTL_FOCUS_PEAK_COLOR_OFFSET	=	6
DISPLAY_CTL_ZEBRA_EN_OFFSET		=	9

DISPLAY_CTL_ADDRESS_SEL_MASK	=	(1 << DISPLAY_CTL_ADDRESS_SEL_OFFSET)
DISPLAY_CTL_SCALER_NN_MASK		=	(1 << DISPLAY_CTL_SCALER_NN_OFFSET)
DISPLAY_CTL_SYNC_INH_MASK		=	(1 << DISPLAY_CTL_SYNC_INH_OFFSET)
DISPLAY_CTL_READOUT_INH_MASK	=	(1 << DISPLAY_CTL_READOUT_INH_OFFSET)
DISPLAY_CTL_COLOR_MODE_MASK		=	(1 << DISPLAY_CTL_COLOR_MODE_OFFSET)
DISPLAY_CTL_FOCUS_PEAK_EN_MASK	=	(1 << DISPLAY_CTL_FOCUS_PEAK_EN_OFFSET)
DISPLAY_CTL_FOCUS_PEAK_COLOR_MASK	=	(7 << DISPLAY_CTL_FOCUS_PEAK_COLOR_OFFSET)
DISPLAY_CTL_ZEBRA_EN_MASK		=	(1 << DISPLAY_CTL_ZEBRA_EN_OFFSET)

 ### DISPLAY_FRAME_ADDRESS_ADDR		=	(DISPLAY_FRAME_ADDRESS * 2)
 ### DISPLAY_FPN_ADDRESS_ADDR		=	(DISPLAY_FPN_ADDRESS * 2)
 ### DISPLAY_GAIN_ADDR				=	(DISPLAY_GAIN * 2)
 ### DISPLAY_H_PERIOD_ADDR			=	(DISPLAY_H_PERIOD * 2)
 ### DISPLAY_V_PERIOD_ADDR			=	(DISPLAY_V_PERIOD * 2)
 ### DISPLAY_H_SYNC_LEN_ADDR			=	(DISPLAY_H_SYNC_LEN * 2)
 ### DISPLAY_V_SYNC_LEN_ADDR			=	(DISPLAY_V_SYNC_LEN * 2)
 ### DISPLAY_H_BACK_PORCH_ADDR		=	(DISPLAY_H_BACK_PORCH * 2)
 ### DISPLAY_V_BACK_PORCH_ADDR		=	(DISPLAY_V_BACK_PORCH * 2)
 ### DISPLAY_H_RES_ADDR				=	(DISPLAY_H_RES * 2)
 ### DISPLAY_V_RES_ADDR				=	(DISPLAY_V_RES * 2)
 ### DISPLAY_H_OUT_RES_ADDR			=	(DISPLAY_H_OUT_RES * 2)
 ### DISPLAY_V_OUT_RES_ADDR			=	(DISPLAY_V_OUT_RES * 2)
 ### DISPLAY_PEAKING_THRESH_ADDR		=	(DISPLAY_PEAKING_THRESH * 2)

 ### DISPLAY_PIPELINE_ADDR           	=	(DISPLAY_PIPELINE * 2)
DISPLAY_PIPELINE_BIPASS_FPN         =	(1 << 0)
DISPLAY_PIPELINE_BIPASS_GAIN        =	(1 << 1)
DISPLAY_PIPELINE_BIPASS_DEMOSIAC    =	(1 << 2)
DISPLAY_PIPELINE_BIPASS_COLORMATRIX =	(1 << 3)
DISPLAY_PIPELINE_BIPASS_GAMMA_TABLE =	(1 << 4)
DISPLAY_PIPELINE_RAW_12BPP          =	(1 << 5)
DISPLAY_PIPELINE_RAW_16BPP          =	(1 << 6)
DISPLAY_PIPELINE_RAW_RIGHT_JUSTIFY  =	(1 << 7)
DISPLAY_PIPELINE_RAW_TEST_PATTERN   =	(1 << 15)

 ### DISPLAY_MANUAL_SYNC_ADDR        =	(DISPLAY_MANUAL_SYNC * 2)
DISPLAY_MANUAL_SYNC_MASK        =	(1)

 ### CCM_11_ADDR						=	(CCM_11 * 2)
 ### CCM_12_ADDR						=	(CCM_12 * 2)
 ### CCM_13_ADDR						=	(CCM_13 * 2)
 ### CCM_21_ADDR						=	(CCM_21 * 2)
 ### CCM_22_ADDR						=	(CCM_22 * 2)
 ### CCM_23_ADDR						=	(CCM_23 * 2)
 ### CCM_31_ADDR						=	(CCM_31 * 2)
 ### CCM_32_ADDR						=	(CCM_32 * 2)
 ### CCM_33_ADDR						=	(CCM_33 * 2)

 ### WL_DYNDLY_0_ADDR				=	(WL_DYNDLY_0 * 2)
 ### WL_DYNDLY_1_ADDR				=	(WL_DYNDLY_1 * 2)
 ### WL_DYNDLY_2_ADDR				=	(WL_DYNDLY_2 * 2)
 ### WL_DYNDLY_3_ADDR				=	(WL_DYNDLY_3 * 2)

 ### MMU_CONFIG_ADDR                 =	(MMU_CONFIG_ADDRESS * 2)
MMU_INVERT_CS                   =	1
MMU_SWITCH_STUFFED              =	2

 ### SYSTEM_RESET_ADDR				=	(SYSTEM_RESET * 2)

 ### FPGA_VERSION_ADDR				=	(FPGA_VERSION * 2)
 ### FPGA_SUBVERSION_ADDR            =	(FPGA_SUBVERSION * 2)

 ### DCG_MEM_START_ADDR				=	(DCG_MEM_START * 2)



#========================================================================================================
#                                   New format registers

#---------------------------------- Wishbone RAM Access -----------------------------------------


RAM_REG_BASE                =	(0x2000)
RAM_REG_BLOCK               =	(RAM_REG_BASE)

# identifier
RAM_IDENTIFIER_REG          =	(RAM_REG_BLOCK + 0x00)
RAM_VERSION_REG             =	(RAM_REG_BLOCK + 0x04)
RAM_SUBVERSION_REG          =	(RAM_REG_BLOCK + 0x08)

# reset and control
RAM_CONTROL                 =	(RAM_REG_BLOCK + 0x0C)
RAM_STATUS                  =	(RAM_REG_BLOCK + 0x10)

RAM_ADDRESS                 =	(RAM_REG_BLOCK + 0x20) # 32 bit 
RAM_BURST_LENGTH            =	(RAM_REG_BLOCK + 0x24)

# Read/write buffers
RAM_BUFFER_START            =	(RAM_REG_BLOCK + 0x200) # 1024*16bit (64-ram page) 
RAM_BUFFER_END              =	(RAM_REG_BLOCK + 0xA00)



RAM_IDENTIFIER =	(0x0040)

RAM_CONTROL_TRIGGER_READ  =	0x0001
RAM_CONTROL_TRIGGER_WRITE =	0x0002

RAM_BURST_LENGTH_MAX =	32

#------------------------------------------------------------------------------------------------




