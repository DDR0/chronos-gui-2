<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Chronos D-Bus API Documentation</title>
		
		<style>
			/* Originally from http://bettermotherfuckingwebsite.com */
			body {
				display: flex;
				flex-direction: column;
				align-items: center;
				margin: 40px 2%;
				line-height: 1.6;
				font-size: 18px;
				color: #444;
				padding: 0 10px;
				tab-size: 4;
				overflow-wrap: break-word; /*Can't be "anywhere", because of FF bug with table sizing.*/
			}
			
			body > * {
				max-width: 650px;
			}
			
			body > table {
				max-width: 975px;
			}
			
			body > code, .codeblock {
				white-space: pre;
				overflow-x: auto;
				display: block;
			}
			
			code, .codeblock {
				background: rgba(0,0,0, 0.1);
				border-radius: 0.2ex;
				padding: 0 0.4ex;
			}
			
			h1,h2,h3 {
				line-height: 1.2;
				width: 100%;
			}
			
			p {
				width: 100%;
			}
			
			thead, th {
				position: sticky;
				top: 0px;
				background: white;
				text-align: left;
			}
			
			th, td {
				padding: 1ex;
				vertical-align: top;
			}
			
			
			svg path {
				stroke: black;
			}
			
			svg text {
				font-family:sans-serif;
				font-size: 16px;
				line-height: 1.25;
				text-align: center;
				text-anchor: middle;
				pointer-events: none; /* Keep links, on rects, working when mouse is over text. */
				user-select: none;
			}
			
			svg rect {
				fill-opacity:.25;
				fill:#10bfbf;
				stroke:#107f7f
			}
			
			svg a:hover {
				opacity: 0.7;
			}
		</style>
		
		<script>
			//Remove HTML-formatting whitespace from code snippets. (Leading newlines, indentation.)
			document.addEventListener('DOMContentLoaded', ()=>{
				document.querySelectorAll('code').forEach(elem => {
					let lines = elem.innerHTML
						.split('\n')
						.filter(line=>line) //Filter to remove non-code lines, mainly the leading newline between <code> and the actual code.
					
					minLeadingTabs = lines
						.filter(line => line.trim())
						.reduce((minimum, line) => Math.min(line.split(/[^\t]/)[0].length, minimum), Infinity)
					
					elem.innerHTML = lines
						.map(line => line.replace(new RegExp(`^\t{0,${minLeadingTabs}}`), '')) //Remove leading snippet-level indentation, it provides nothing.
						.join('\n')
				})
			})
		</script>
	</head>
	<body>
		<h1>Chronos D-Bus API</h1>
		
		
		<p>This documentation covers the Chronos 1.4 <a href="https://www.freedesktop.org/wiki/Software/dbus/">D-Bus</a> API. The API has two major components: The <a href="#control-api">Coordinator API</a> (formerly the Control API) and the <a href="#video-api">Video API</a>. There is also a reference client written in Python which is used for the user interface.</p>
		
		<p>You can use the D-Bus API to write your own application on the camera. This application will be able to display a UI on the back of the camera as well as respond to remote HTTP requests over MiniUSB and the network.</p>
		
		<p>If you only need to control the camera remotely, you should consider using the <a href="https://github.com/krontech/chronos-web-interface">HTTP interface</a> instead. The HTTP interface lets you send commands to the camera over the network, and is used by the (planned) remote-control app. It is easier to develop using the HTTP interface than it is using the D-Bus interfaces.</p>
		
		<p>Note: All examples in this document are given in Python, since the reference client was written in it.</p>
		
		<h2>Architecture</h2>
		
		<p>The D-Bus Coordinator and Video APIs sit between the hardware and the applications running on the camera.</p>
		
		<svg id="SVGRoot" version="1.1" viewBox="0 0 701 241" xmlns="http://www.w3.org/2000/svg">
			<g id="layer1" transform="translate(-29.5,-119.5)" inkscape:groupmode="layer" inkscape:label="Layer 1">
				<a href="#hardware"><rect id="rect2667" x="40" y="160" width="160" height="140"/></a>
				<a href="#control-api"><rect id="rect2669" x="300" y="160" width="160" height="60"/></a>
				<a href="https://github.com/krontech/chronos-cli/blob/master/src/pipeline/README.md"><rect id="rect2671" x="300" y="240" width="160" height="60"/></a>
				<a href="#user-interface"><rect id="rect2673" x="580" y="130" width="140" height="60"/></a>
				<a href="#http-interface"><rect id="rect2675" x="580" y="210" width="140" height="60"/></a>
				<a href="#ych"><rect id="rect2677" x="580" y="290" width="140" height="60" style="fill-opacity:1;fill:#6ecff0;stroke:#2c4d8e"/></a>
				<text id="text3352" x="120.00391" y="225.96484">
					<tspan id="tspan3350" x="120.00391" y="225.96484">Chronos 1.4</tspan><tspan id="tspan3354" x="120.00391" y="245.96484">Hardware</tspan>
				</text>
				<text id="text3358" x="380.33594" y="195.96484">
					<tspan id="tspan3356" x="380.33594" y="195.96484">Coordinator API</tspan>
				</text>
				<text id="text3362" x="380.72266" y="275.96484">
					<tspan id="tspan3360" x="380.72266" y="275.96484">Video API</tspan>
				</text>
				<text id="text3366" x="650.00391" y="154.41406">
					<tspan id="tspan3364" x="650.00391" y="154.41406">User Interface</tspan><tspan id="tspan3368" x="650.00391" y="174.41406">(chronos-gui-2)</tspan>
				</text>
				<text id="text3367" x="649.64062" y="234.41406">
					<tspan id="tspan3364-3" x="649.64062" y="234.41406">HTTP Interface</tspan>
					<tspan id="tspan3368-9" x="649.64062" y="254.41406">(planned)</tspan>
				</text>
				<text id="text3348" x="650.44141" y="325.96484" style="fill:#2c4d8e">
					<tspan id="tspan3346" x="650.44141" y="325.96484">Your Client Here</tspan>
				</text>
				<path id="path3393" d="m300 257.69-100-15.385" inkscape:connection-end="#rect2667" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3397" d="m460 180.31 120 37.698" inkscape:connection-end="#rect2675" inkscape:connection-start="#rect2669" inkscape:connector-type="polyline"/>
				<path id="path3401" d="m452.32 240 127.68-52.963" inkscape:connection-end="#rect2673" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3403" d="m460 260.52 120-14.222" inkscape:connection-end="#rect2675" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3405" d="m460 284.22 120 21.333" inkscape:connection-end="#rect2677" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3409" d="m580 167.78-120 13.333" inkscape:connection-end="#rect2669" inkscape:connection-start="#rect2673" inkscape:connector-type="polyline"/>
				<path id="path3411" d="m587.69 290-145.38-70" inkscape:connection-end="#rect2669" inkscape:connection-start="#rect2677" inkscape:connector-type="polyline"/>
				<path id="path3417" d="m200 217.69 100-15.385" inkscape:connection-end="#rect2669" inkscape:connection-start="#rect2667" inkscape:connector-type="polyline"/>
			</g>
		</svg>
		
		<p>The APIs provide a way to configure the camera hardware. The APIs also emit updates so that clients can keep themselves up-to-date when the camera is reconfigured. For example, if the HTTP interface receives a request to change the exposure time of the camera, then the user interface on the camera will need to update itself to reflect the new exposure time.</p>
		
		
		<h2><a name="hardware">Hardware</a></h2>
		
		<p>The APIs primarily drive the FPGA of the Chronos, as well as set up the video pipeline to display and save content. While the FPGA image itself is proprietary, the register definitions are available as part of the implementation of the APIs.</p>
		
		
		<h2><a name="control-api">Coordinator API</a></h2>
		
		<p>The Coordinator D-Bus API deals with configuring the camera, as opposed to the video API which is responsible for playing back and saving footage.</p>
		
		<h3>Connecting</h3>
		
		<p>To connect to the Coordinator API, connect to the D-Bus service/path/interface as in the following example:</p>
		
		<code>
			from PyQt5.QtDBus import QDBusInterface, QDBusConnection
			
			cameraControlAPI = QDBusInterface(
				"com.krontech.chronos.control", #Service
				"/com/krontech/chronos/control", #Path
				"", #Interface
				QDBusConnection.systemBus() )
		</code>
		
		<p>To use the mock interface, to avoid misconfiguring the camera during development, connect to the <code>com.krontech.chronos.control<strong>.mock</strong></code> service instead of <code>com.krontech.chronos.control</code>.</p>
		
		<h3>Methods</h3>
		
		<p>All methods result in a reply containing key/value pairs. The map can contain an optional 'value' entry with the data resulting from the function call, <strong>or</strong> in the case of an error an 'errorName' and 'message' entry. If there is no errorName, then no error should have occured.</p>
		
		<p>Available methods are:</p>
		<ul>
			<li><code><strong>get</strong>([string valueName, …]) → {string:value, …}</code> — Return camera setting values for all strings in the list passed in. See <a href="#values">Values</a> for a list of valid keys.</li>
			
			<li><code><strong>set</strong>({string valueName: any value, …})</code> — Update camera values named by string to their new value. See <a href="#values">Values</a> for a list of valid keys.</li>
			
			<li><code><strong>availableKeys</strong>() → [string valueName, …]</code> — Get a list of available camera settings keys, for use with <code>get</code> or <code>set</code>.</li>
			
			<li><code><strong>availableCalls</strong>() → [string callName, …]</code> — Get a list of available camera settings keys, for use with <code>get</code> or <code>set</code>.</li>
			
			<li><code><strong>powerDown</strong>()</code> — Turn off the camera. Useful in conjunction with the "Turn camera on when power connected" checkbox in the Battery & Power screen.</li>
			
			<li><code><strong>framerateForResolution</strong>(hRes: int, vRes: int) → float</code> — Returns the frames per seconds a resolution will record at. Non-valid resolutions will return undefined results.</li>
			
			<li><code><strong>resolutionIsValid</strong>(hOffset: int, vOffset: int, hRes: int, vRes: int) → bool</code> — Returns true if the supplied video resolution and offset is valid for recording. A resolution is not valid if it is offset too far. All parameters are positive integers.</li>
			
			<li>
				<code><strong>calibrate</strong>({string testName: boolean run})</code> — Calibrate the camera. Each calibration for which run is true is ran. Warning - some calibrations may require equipment to run correctly. For example, while black cal is easy to re-run, it is much harder to run white balance since you will need a diffuse, true-white light source. Available calibrations are:
				<ul>
					<li><code>analogCal</code>: Sensor internal calibration.</li>
					<li><code>blackCal</code>: The normal black calibration routine where you have to cover the lense.</li>
					<li><code>zeroTimeBlackCal</code>: The fast black calibration where exposure time is set to as close to zero as possible.</li>
					<li><code>whiteBalance</code>: Take a white reference and compute the white balance matrix. (API value <code>whiteBalance</code>.)</li>
				</ul>
			</li>
			
			<li><code><strong>takeStillReferenceForMotionTriggering</strong>()</code> — When motion triggering is used, the camera may need to be trained to recognise a still scene. For example, if there is some background motion such as trees swaying in the wind, this function will teach the camera to ignore it as background noise.</li>
			
			<li><code><strong>saveCalibrationData</strong>(str toFolder)</code> — Write all sensor calibration data (eg; black cal, white balance) to the folder specified. Usually, one would use the folder <code>'/dev/sda'</code>, as that represents the first external storage device plugged in on Linux systems such as the camera runs. Calibration data may be restored using the isomorphic <code>loadCalibrationData</code>.</li>
			
			<li><code><strong>loadCalibrationData</strong>(str fromFolder)</code> — Restores the calibration data saved by <code>saveCalibrationData</code>, overwriting all active calibration data.</li>
			
			<li><code><strong>applySoftwareUpdate</strong>()</code> — Install another firmware version from an external storage device. See the manual on "updating" for more details.</li>
			
			<li><code><strong>waterfallMotionMap</strong>({[id: str name], ['startFrame': int], ['endFrame': int]}) → {startFrame: int, endframe: int, heatmap: 16×n little-endian byte map}</code> — (unstable)
				<p>Generate a waterfall-style heatmap from each of the 16 quadrants of recorded motion data. Returns an 16×n greyscale bitmap, one byte per pixel.</p>
				<p>Arguments are a map specifying:
					<ul>
						<li>id: What segment ID to query. If not supplied, all recorded data will be considered "the segment".</li>
						<li>startFrame = 0: Optional frame to start from. Defaults to the first frame of the segment.</li>
						<li>endFrame = ∞: Optional frame to end at. Defaults to the last frame of the segment.</li>
					</ul>
				</p>
				<p>Segment IDs, and their respective startFrame and endFrames, can be read from the recordedSegments value.</p>
			</li>
			
			<li><code><strong>saveRegions</strong>([{[id: str], [start: int], [end: int], path: str, format: { fps: float, bpp: float, maxBitrate: float }}, …])</code> — (unstable) Save each region in the input list to file.
				<p>Save video clips to disk or network.</p>
				<p>Accepts a list of regions, returns a list of statuses.</p>
				<p>As with waterfallMotionMap, if no segment id is specified, 'all recorded data' is considered to be the segment, and start/end is relative to all recorded data.</p>
				Python example:
				<code class=codeblock>
					api.control('saveRegions', [{
						"start": 19104, 
						"end": 39801, 
						"id": 'ldPxTT5R', #from api value recordedSegments
						"path": '/dev/sda/',
						"format": {
							'fps': 29.97, #NTSC video
							'bpp': .7,
							'maxBitrate': 40, #mbps
						},
					}])
				</code>
				<p>A list of regions available to save and paths available to save to can be retrieved with <code>api.control('get', ['recordedSegments', 'externalStorage'])</code>.</p>
			</li>
			
			<li><code><strong>formatStorage</strong>(str path)</code> — Erase and prepare the device at <em>path</em> for saving video to. A list of paths available to format to can be retrieved with <code>api.control('get', ['externalStorage'])</code>. Be careful not to erase saved footage!</li>
			
			<li><code><strong>unmount</strong>(str path)</code> — Unmount the storage device mounted at <em>path</em>. A list of paths available to unmount to can be retrieved with <code>api.control('get', ['externalStorage'])</code>.
				<p>To remount a device, either reinsert it or SSH into the camera and run the mount command.</p>
			</li>
			
			<li><code><strong>df</strong>() → str output</code> — Returns text written to stdout by the linux utility <code>df</code>. This is mostly useful for debugging.
				<p>Example:
					<code class=codeblock>
						Filesystem     1K-blocks   Used Available Use% Mounted on
						/dev/root         757856 158420   5683476  22% /
						/dev/mmcblk0p1     39497   3961     35537  11% /boot
						/dev/sda1          39497   2973     36525   8% /media/sda1
						/dev/sda2         757856 167288   5574608  23% /media/sda2
					</code>
				</p>
			</li>
			
			<li><code><strong>testNetworkStorageCredentials</strong>({[networkStorageAddress: str], [networkStorageUsername: str], [networkStoragePassword: str]}) → str error</code> — Check if a remote file share is available. Returns either a string containing the error message if the share is not connectable-to, or an empty string if the credentials were valid. networkStorageAddress, networkStorageUsername, and networkStoragePassword may be provided to override the API values of the same names.</li>
		</ul>
		
		<p>In addition, when a camera setting is changed, a signal named the key is emitted on the D-Bus interface. It can be intercepted with <code>QDBusConnection.systemBus().connect('com.krontech.chronos.control.mock', '/', '', NAME_OF_KEY, CALLBACK)</code>.
		
		
		<h3><a name="values">Values</a></h3>
		
		<p>API Values hold and reflect the state of the camera. They are read and written using the <code>get</code> and <code>set</code> method calls listed above. A list of value names can be retrieved by calling the <code>availableKeys</code> method.</p>
		
		<p>Values can have different levels of mutability:</p>
		<ul>
			<li><strong>Variable</strong> values can be set through the API, but may be changed externally as well. They can be set, retrieved, and observed. (Observation, in this case, means a D-Bus signal with the same name as the value will be emitted. Refer to <a href="../src/api.py#observe">api.py:observe</a> for an example.)</li>
			<li>Values which are a <strong>property</strong>, on the other hand, only change in response to external stimulus. Properties can't be set, but they can be retrieved and observed as they changed. These are things like battery level and trigger status.</li>
			<li><strong>Constant</strong> values do not change over the course of a connection, although they may be changed if the camera firmware is upgraded. For example, firmware version and the amount of RAM installed are both constants.</li>
		</ul>
		
		<p>Available values are:</p>
		<table>
			<thead>
				<tr>
					<th>Value Name</th>
					<th>Type</th>
					<th>Mutability</th>
					<th>Description</th>
				</tr>
			</thead>
			
			<tbody>
				<tr>
					<td><code>batteryCharge</code></td>
					<td>decimal</td>
					<td>property</td>
					<td>On a scale of 0.0 to 1.0, how full is the camera battery? 0 is dead, and 1 is fully charged.</td>
				</tr>
				<tr>
					<td><code>batteryVoltage</code></td>
					<td>decimal</td>
					<td>property</td>
					<td>DThe voltage of the battery, in volts. A happy battery outputs between 12v and 12.5v.</td>
				</tr>
				<tr>
					<td><code>cameraApiVersion</code></td>
					<td>string</td>
					<td>constant</td>
					<td>The iteration of this API. Adheres to <a href="https://semver.org/">SemVer</a>.</td>
				</tr>
				<tr>
					<td><code>cameraFpgaVersion</code></td>
					<td>string</td>
					<td>constant</td>
					<td>The firmware iteration the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">field-programmable gate array</a> inside the Chronos is running. (The FPGA is primarily responsible for recording the high-speed video coming off the sensor to a buffer in RAM.)</td>
				</tr>
				<tr>
					<td><code>cameraMemoryGB</code></td>
					<td>decimal</td>
					<td>constant</td>
					<td>Amount of RAM installed in the Chronos in <a href="https://en.wikipedia.org/wiki/Gigabyte">GB</a> (vs <a href="https://en.wikipedia.org/wiki/Gibibyte">GiB</a>). This will correspond to the memory amount printed on the bottom of your camera, if you haven't made any modification.</td>
				</tr>
				<tr>
					<td><code>cameraModel</code></td>
					<td>string</td>
					<td>constant</td>
					<td>The product identifier of the camera hosting the API. This corresponds to the model printed on the bottom of your camera. Example: <code>CR14-1.0</code></td>
				</tr>
				<tr>
					<td><code>cameraSerial</code></td>
					<td>string</td>
					<td>constant</td>
					<td>The serial number of the product the API is running on. This corresponds to the SN printed on the bottom of your camera. Example: <code>00204</code></td>
				</tr>
				<tr>
					<td><code>commonlySupported<br>Resolutions</code></td>
					<td>list</td>
					<td>constant</td>
					<td>
						A list of maps. Each map indicates a preset by specifying <code>hRes</code> (int, px), <code>vRes</code> (int, px), and <code>framerate</code> (decimal, frames per second). Partial example:
						<code class="codeblock">
							[{
								'hRes': 1280, 
								'vRes': 1024, 
								'framerate': 1057.362,
							}, …]
						</code>
					</td>
				</tr>
				<tr>
					<td><code>currentCameraState</code></td>
					<td>enum</td>
					<td>property</td>
					<td>Indicates what the camera is doing. One of <code>normal</code>, <code>saving</code> or <code>recording</code>. When saving (to file), parts of the API may be unresponsive. The main difference between <code>normal</code> and <code>recording</code> is whether the red indicator lights on the chronos are red or not. Some actions, like 'stop recording' or 'stop saving', only make sense in certain states.</td>
				</tr>
				<tr>
					<td><code>currentVideoState</code></td>
					<td>enum</td>
					<td>variable</td>
					<td>Indicates what the video display is showing. One of <code>viewfinder</code> or <code>playback</code>.</colgroup>. In <code>viewfinder</code> mode, the video on the back of the camera is showing what the sensor is seeing. In <code>playback</code> mode, the video is showing footage previously recorded in RAM.</td>
				</tr>
				<tr>
					<td><code>disableOverwriting<br>RingBuffer</code></td>
					<td>boolean</td>
					<td>variable</td>
					<td>In segmented mode, disable overwriting earlier recorded ring buffer segments.</td>
				</tr>
				<tr>
					<td><code>externallyPowered</code></td>
					<td>boolean</td>
					<td>property</td>
					<td>Returns True if the camera is running on mains power. In this mode, the battery will recharge until full.</td>
				</tr>
				<tr>
					<td><a name=focusPeakingColor><code>focusPeakingColor</code></a></td>
					<td>integer</td>
					<td>variable</td>
					<td>
						An integer specifying the color of focus peaking, one of the available focus aids. Like HTML/CSS, this value is composed of four packed 8-bit channels, representing Red, Green, Blue, and Alpha (strength). In <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a>, this is formatted as 0x<span style="color: #D00F;">RR</span><span style="color: #0B0F;">GG</span><span style="color: #00DF;">BB</span><span style="color: #000F;">AA</span>. For example, <code style="color: #AA00AAFF;">0xAA00AAFF</code> is maximum-strength purple, because red and blue are both set to AA, and alpha is set to FF. <code style="color: #C1681988;">0xC1681988</code> is half-strength brown.
						<br>
						To turn off/disable focus peaking, set this value to 0.
					</td>
				</tr>
				<tr>
					<td><code>recordedSegments</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingAnalogGain</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingExposureNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingHRes</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingHoffset</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingPeriodNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingVRes</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingVoffset</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorFramerateMax</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorHIncrement</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorHMax</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorHMin</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorMaxExposureNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorMaxShutterAngle</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorMinExposureNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorName</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorPixelFormat</code></td>
					<td>string</td>
					<td>constant</td>
					<td>Either <code>BYR2</code> for color cameras or <code>y12</code> for monochromatic cameras. This corresponds to the Color or Mono information printed on the bottom of the Chronos.</td>
				</td>
				<tr>
					<td><code>sensorPixelRate</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorQuantizeTimingNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorVIncrement</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorVMax</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorVMin</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingExposureDelayNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingMaxExposureNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingMaxPeriod</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingMaxShutterAngle</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingMinExposureNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingMinPeriod</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingQuantization</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>triggerCapabilities</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>triggerConfiguration</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>triggerDelayNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>triggerState</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>triggers</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>whiteBalance</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>zebraStripesEnabled</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
			</tbody>
		</table>
		
		<p>Some settings related to the video pipeline take a little while to update, so it's recommended to set them all at once with one call to to <code>set</code>.</p>
		
		
		<h3>Reference Client</h3>
		
		<p>A Python reference client for the control API is available. If you're using Python to script, it may be useful as a library. Otherwise, it may serve as a useful example how to connect to and use the D-Bus API.</p>
		
		<p>It is <strong>not</strong> required to use the reference client. The client simply sands down some of the rough edges of the D-Bus API. For example, when <code>get</code>ting or <code>set</code>ting a single value, the reference client automatically converts the single value into the list the D-Bus API requires. It also emits an update signal immediately on subscription, which eliminates the need for separate initialiser code in many cases.</p>
		
		<p>The reference API has the following available methods:</p>
		
		<ul>
			<li><code><strong>video</strong>(methodName: string, optional args: any)</code> — Convenience method to invoke one of the D-Bus API Video methods. See the <a href="https://github.com/krontech/chronos-cli/blob/master/src/pipeline/README.md">video api documentation</a> for details.</li>
			<li><code><strong>control</strong>(methodName: string, optional args: any)</code> — </li>
			<li><code><strong>get</strong>(string or [strings])</code> — Convenience method to invoke one of the D-Bus API Video methods. See the <a href="#values">control settings keys</a> for a list of values. If a string is passed, this method will automatically wrap it in a list before calling the underlying D-Bus method and unwrap the returned list.</li>
			<li><code><strong>set</strong>({key: value})</code> — Wrapper for <code>control('set', {…})</code>. See the <a href="#values">control settings keys</a> for a list of values.</li>
			<li><code><strong>observe</strong>(valueName: string, callback: Callable[[Any], None])</code> — Invoke the callback with the new value when the value changes. The value is initially presumed to be unknown, and so is considered to change to the current value is when the subscription is started. valueName is one of the <a href="#values">control settings keys</a>.</li>
			<li><code><strong>observe_future_only</strong></code> — Like <code>observe</code>, but the callback is not called on subscription. This is useful for some of the more complex compound values which can arise around sliders and such.</li>
			<li><code><strong>@silenceCallbacks(Qt Widget)</strong></code> — Function decorator for a callback. Before a decorated callback is called, this turns off events for the supplied Qt Widget. For example, on the main screen of the UI, the callback
				<code class="codeblock">
					@pyqtSlot(int)
					@silenceCallbacks('uiExposureSlider')
					def updateExposureNs(self, newExposureNs):
						self.uiExposureSlider.setValue(newExposureNs)
				</code>
			is used by 
				<code class="codeblock">
					api.observe('recordingExposureNs', self.updateExposureNs)
				</code>
			to update the exposure slider when the exposure is changed externally.
			</li>
		</ul>
		
		
		
		<h2><a name="video-api">Video API</a></h2>
		<p>The video interface deals with getting the video data from A to B.</p>
		
		<p>The <a href="https://github.com/krontech/chronos-cli/blob/master/src/pipeline/README.md">full documentation</a> for the video API is available in the <a href="https://github.com/krontech/chronos-cli">chronos-cli repository</a>.</p>
		
		
		
		<h2><a name="user-interface">User Interface</a></h2>
		<p>The user interface, on the screen on the back of the Chronos, uses the D-Bus API to drive the camera and keep itself in sync with the state the camera is in.</p>
		
		<h2><a name="http-interface">HTTP Interface</a></h2>
		<p><em>I have not written this program yet, but what is documented as follows will follow.</em></p>
		<p>The HTTP interface exposes a web API. It also provides web app which uses the web API. The web app can be used from any phone, tablet, or laptop running a modern web browser.</p>
		
		<p>The HTTP interface is very similar to the D-Bus interface. It mostly exposes the same method calls, and provides the same events. However, it also contains an authentication mechanism so other people can't control your camera without your permission. The D-Bus API does not need an authentication mechanism, since anything capable of talking to it is already running on the camera and can do anything the API can do.</p>
		
		
		
		<h2><a name="ych">Your Client Here</a></h2>
		
		<p>So, you have a specialized application you want the camera to perform? Perhaps you just want to lock down the back-of-camera UI? Luckily for you, it is easy to develop your own application to run on the Chronos.</p>
		
		<p>There are two approaches to developing an app. You can write the code on the camera, or you can write the code on a virtual machine and copy it to the camera later. If you want to set up a VM, refer to <a href="../util/chronos debian setup instructions.txt">~util/chronos debian setup instructions.txt</a>. The following instructions assume you have a working development environment, either on the camera or in a virtual machine.</p>
		
		
		<h3>Connecting to the Camera</h3>
		
		<p>Developing directly on your Chronos, via SSH or file upload, is simpler than developing on a virtual machine. If you develop via SSH, you'll usually run commands and edit files in-place on the camera with Vim or Emacs. If you prefer file upload, you'll set up a little watcher-script that will restart your application when you change a file. The advantage of uploading the files is being able to edit them locally, with your preferred text editor, although this method is a little more complex. Either way the files on the camera are changed, the result is the same.</p>
		
		<p>Before making any changes to your camera, it is strongly recommended to make a backup of your system SD card. Pop the SD card out of the bottom of the camera, insert it into your computer, and then make a backup of the card filesystems. (Not the files themselves.) On Linux, this can be done with <code>gzip /dev/sdb --to-stdout --verbose > chronos-fs-$(date +%F).gz</code>, where <code>/dev/sdb</code> is the device you just plugged in. You can list plugged-in devices with <code>lsblk</code>. (You should see <code>BOOT</code> and <code>ROOTFS</code> on your microSD card.) After you've taken your backup, which will take a while to complete, test it by restoring it to a <em>different</em> microSD card. If you don't have a spare card to test with, it is advised to say a brief prayer instead.</p>
		
		<p>You can connect via the local network by plugging an Ethernet cable into your camera, or connect directly to your computer with a MicroUSB cable. Either way, the camera will get an IP address which you can SSH to. For example, I have my camera connected to my PC via USB, so I run <code>ssh root@192.168.12.1</code> to connect to my camera. I can also visit <code>fish://root@192.168.12.1/root/</code> in Dolphin to browse the files on my camera graphically. When prompted, the password is "chronos", or whatever you set it to.</p>
		
		<p>The camera runs Debian 7 (Wheezy). As such, most common linuxisims will still work, but modern programs must be compiled from scratch. The back-of-camera UI, chronos-gui-2, lives in <code>~/gui</code>. For your own app, you may wish to build new screens for chronos-gui-2, or use it as a reference for developing your own Qt app. The D-Bus API resides in <code>~/chronos-cli</code>. All software running on the CPU is open source, and can be <a href="https://github.com/krontech">freely downloaded from GitHub</a>. If you'd like to contribute a bug fix or a new feature to the existing app, please drop us a line on the forum so we can coordinate!</p>
		
		<p>So, basically, make a new <code>my_client_app.py</code> file on the camera and run it with <code>python3 my_client_app.py</code>. Refer to above for how to make it do stuff.</p>
	</body>
</html>