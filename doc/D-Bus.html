<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Chronos D-Bus API Documentation</title>
		
		<style>
			/* Originally from http://bettermotherfuckingwebsite.com */
			body {
				display: flex;
				flex-direction: column;
				align-items: center;
				margin: 40px 2%;
				line-height: 1.6;
				font-size: 18px;
				color: #444;
				padding: 0 10px;
				tab-size: 4;
			}
			
			body > * {
				max-width: 650px;
			}
			
			body > table {
				max-width: 975px;
			}
			
			body > code, .codeblock {
				white-space: pre;
				overflow-x: auto;
				display: block;
			}
			
			code, .codeblock {
				background: rgba(0,0,0, 0.1);
				border-radius: 0.2ex;
				padding: 0 0.4ex;
			}
			
			h1,h2,h3 {
				line-height: 1.2;
				width: 100%;
			}
			
			thead, th {
				position: sticky;
				top: 0px;
				background: white;
				text-align: left;
			}
			
			th, td {
				padding: 1ex;
			}
			
			
			svg path {
				stroke: black;
			}
			
			svg text {
				font-family:sans-serif;
				font-size: 16px;
				line-height: 1.25;
				text-align: center;
				text-anchor: middle;
				pointer-events: none; /* Keep links, on rects, working when mouse is over text. */
				user-select: none;
			}
			
			svg rect {
				fill-opacity:.25;
				fill:#10bfbf;
				stroke:#107f7f
			}
			
			svg a:hover {
				opacity: 0.7;
			}
		</style>
		
		<script>
			//Remove HTML-formatting whitespace from code snippets. (Leading newlines, indentation.)
			document.addEventListener('DOMContentLoaded', ()=>{
				document.querySelectorAll('code').forEach(elem => {
					let lines = elem.innerHTML
						.split('\n')
						.filter(line=>line) //Filter to remove non-code lines, mainly the leading newline between <code> and the actual code.
					
					minLeadingTabs = lines
						.filter(line => line.trim())
						.reduce((minimum, line) => Math.min(line.split(/[^\t]/)[0].length, minimum), Infinity)
					
					elem.innerHTML = lines
						.map(line => line.replace(new RegExp(`^\t{0,${minLeadingTabs}}`), '')) //Remove leading snippet-level indentation, it provides nothing.
						.join('\n')
				})
			})
		</script>
	</head>
	<body>
		<h1>Chronos D-Bus API</h1>
		
		
		
		<p>This documentation covers the Chronos 1.4 <a href="https://www.freedesktop.org/wiki/Software/dbus/">D-Bus</a> API. The API has two major components: The Control API and the Video API. There is also a reference client written in Python which is used for the user interface.</p>
		
		<p>You can use the D-Bus API to write your own application on the camera. This application will be able to display a UI on the back of the camera as well as respond to remote HTTP requests over MiniUSB and the network.</p>
		
		<p>If you only need to control the camera remotely, you should consider using the [planned, as of writing] HTTP interface instead. The HTTP interface lets you send commands to the camera over the network, and is used by the [planned, as of writing] remote-control app. It is easier to develop for the HTTP interface than the D-Bus interface.</p>
		
		
		<h2>Architecture</h2>
		
		<p>The D-Bus Control and Video APIs sit between the hardware and the applications running on the camera.</p>
		
		<svg id="SVGRoot" version="1.1" viewBox="0 0 701 241" xmlns="http://www.w3.org/2000/svg">
			<g id="layer1" transform="translate(-29.5,-119.5)" inkscape:groupmode="layer" inkscape:label="Layer 1">
				<a href="#hardware"><rect id="rect2667" x="40" y="160" width="160" height="140"/></a>
				<a href="#control-api"><rect id="rect2669" x="300" y="160" width="160" height="60"/></a>
				<a href="https://github.com/krontech/chronos-cli/blob/master/src/pipeline/README.md"><rect id="rect2671" x="300" y="240" width="160" height="60"/></a>
				<a href="#user-interface"><rect id="rect2673" x="580" y="130" width="140" height="60"/></a>
				<a href="#http-interface"><rect id="rect2675" x="580" y="210" width="140" height="60"/></a>
				<a href="#ych"><rect id="rect2677" x="580" y="290" width="140" height="60" style="fill-opacity:1;fill:#6ecff0;stroke:#2c4d8e"/></a>
				<text id="text3352" x="120.00391" y="225.96484">
					<tspan id="tspan3350" x="120.00391" y="225.96484">Chronos 1.4</tspan><tspan id="tspan3354" x="120.00391" y="245.96484">Hardware</tspan>
				</text>
				<text id="text3358" x="380.33594" y="195.96484">
					<tspan id="tspan3356" x="380.33594" y="195.96484">Control API</tspan>
				</text>
				<text id="text3362" x="380.72266" y="275.96484">
					<tspan id="tspan3360" x="380.72266" y="275.96484">Video API</tspan>
				</text>
				<text id="text3366" x="650.00391" y="154.41406">
					<tspan id="tspan3364" x="650.00391" y="154.41406">User Interface</tspan><tspan id="tspan3368" x="650.00391" y="174.41406">(chronos-gui-2)</tspan>
				</text>
				<text id="text3367" x="649.64062" y="234.41406">
					<tspan id="tspan3364-3" x="649.64062" y="234.41406">HTTP Interface</tspan>
					<tspan id="tspan3368-9" x="649.64062" y="254.41406">(planned)</tspan>
				</text>
				<text id="text3348" x="650.44141" y="325.96484" style="fill:#2c4d8e">
					<tspan id="tspan3346" x="650.44141" y="325.96484">Your Client Here</tspan>
				</text>
				<path id="path3393" d="m300 257.69-100-15.385" inkscape:connection-end="#rect2667" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3397" d="m460 180.31 120 37.698" inkscape:connection-end="#rect2675" inkscape:connection-start="#rect2669" inkscape:connector-type="polyline"/>
				<path id="path3401" d="m452.32 240 127.68-52.963" inkscape:connection-end="#rect2673" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3403" d="m460 260.52 120-14.222" inkscape:connection-end="#rect2675" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3405" d="m460 284.22 120 21.333" inkscape:connection-end="#rect2677" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3409" d="m580 167.78-120 13.333" inkscape:connection-end="#rect2669" inkscape:connection-start="#rect2673" inkscape:connector-type="polyline"/>
				<path id="path3411" d="m587.69 290-145.38-70" inkscape:connection-end="#rect2669" inkscape:connection-start="#rect2677" inkscape:connector-type="polyline"/>
				<path id="path3417" d="m200 217.69 100-15.385" inkscape:connection-end="#rect2669" inkscape:connection-start="#rect2667" inkscape:connector-type="polyline"/>
			</g>
		</svg>
		
		<p>The APIs provide a way to configure the camera hardware. The APIs also emit updates so that clients can keep themselves up-to-date when the camera is reconfigured. For example, if the HTTP interface receives a request to change the exposure time of the camera, then the user interface on the camera will need to update itself to reflect the new exposure time.</p>
		
		
		<h2><a name="hardware">Hardware</a></h2>
		
		<p>The APIs primarily drive the FPGA of the Chronos, as well as set up the video pipeline to display and save content. While the FPGA image itself is proprietary, the register definitions are available as part of the implementation of the APIs.</p>
		
		
		<h2><a name="control-api">Control API</a></h2>
		
		<p>The control D-Bus API deals with configuring the camera, as opposed to the video API which is responsible for playing back and saving footage.</p>
		
		<h3>Connecting</h3>
		
		<p>To connect to the control API, connect to the D-Bus service/path/interface as in the following example:</p>
		
		<code>
			from PyQt5.QtDBus import QDBusInterface, QDBusConnection
			
			cameraControlAPI = QDBusInterface(
				'com.krontech.chronos.control', #Service
				'/', #Path
				'', #Interface
				QDBusConnection.systemBus() )
		</code>
		
		<p>To use the mock interface, to avoid misconfiguring the camera during development, connect to the <code>com.krontech.chronos.control<strong>.mock</strong></code> service instead of <code>com.krontech.chronos.control</code>.</p>
		
		<h3>Methods</h3>
		
		<ul>
			<li><code><strong>get</strong>([string, string, …])→{string:value, string:value, …}</code> — Return camera setting values. See <a href="#control-settings">Settings</a> for a list of valid keys.</li>
			<li><code><strong>set</strong>({string:value, string:value, …})</code> — Update a camera setting value. See <a href="#control-settings">Settings</a> for a list of valid keys.</li>
			<li><code><strong>available_keys</strong> → [string, string, …]</code> — Get a list of available camera settings keys, for use with <code>get</code> or <code>set</code>.</li>
			<li><code><strong>framerate_for_resolution</strong>(hRes: int, vRes: int) → float</code> — Returns the frames per seconds a resolution will record at. Non-valid resolutions will return undefined results.</li>
			<li><code><strong>resolution_is_valid</strong>(hOffset: int, vOffset: int, hRes: int, vRes: int) → bool</code> — Returns true if the supplied video resolution and offset is valid for recording. A resolution is not valid if it is offset too far. All parameters are positive integers.</li>
			<li><code><strong>power_down</strong></code> — Turn off the camera. Useful in conjunction with the "Turn camera on when power connected" checkbox in the Battery & Power screen.</li>
		</ul>
		
		<p>In addition, when a camera setting is changed, a signal named the key is emitted on the D-Bus interface. It can be intercepted with <code>QDBusConnection.systemBus().connect('com.krontech.chronos.control.mock', '/', '', NAME_OF_KEY, CALLBACK)</code>.
		
		
		<h3><a name="control-settings">Settings Keys</a></h3>
		
		<p>Control settings keys hold the state of the camera. These keys are used with the <code>get</code> and <code>set</code> method calls. They can be retrieved with the <code>available_keys</code> method.</p>
		
		<p>Keys have different levels of mutability. <strong>Constant</strong> keys do not change over the course of a connection, although they may be changed if the camera is upgraded. These are things like firmware version and the amount of RAM installed. Keys which are a <strong>property</strong>, on the other hand, only change in response to external stimulus. Properties can't be set through the API. These are things like battery level and trigger status. <strong>Variable</strong> keys are settable through the API, but may be changed externally as well.</p>
		
		<table>
			<thead>
				<tr>
					<th>Setting Key</th>
					<th>Type</th>
					<th>Mutability</th>
					<th>Description</th>
				</tr>
			</thead>
			
			<tbody>
				<tr>
					<td><code>batteryCharge</code></td>
					<td>decimal</td>
					<td>property</td>
					<td>On a scale of 0.0 to 1.0, how full is the camera battery? 0 is dead, and 1 is fully charged.</td>
				</tr>
				<tr>
					<td><code>batteryVoltage</code></td>
					<td>decimal</td>
					<td>property</td>
					<td>DThe voltage of the battery, in volts. A happy battery outputs between 12v and 12.5v.</td>
				</tr>
				<tr>
					<td><code>cameraApiVersion</code></td>
					<td>string</td>
					<td>constant</td>
					<td>The iteration of this API. Adheres to <a href="https://semver.org/">SemVer</a>.</td>
				</tr>
				<tr>
					<td><code>cameraFpgaVersion</code></td>
					<td>string</td>
					<td>constant</td>
					<td>The firmware iteration the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">field-programmable gate array</a> inside the Chronos is running. (The FPGA is primarily responsible for recording the high-speed video coming off the sensor to a buffer in RAM.)</td>
				</tr>
				<tr>
					<td><code>cameraMemoryGB</code></td>
					<td>decimal</td>
					<td>constant</td>
					<td>Amount of RAM installed in the Chronos in <a href="https://en.wikipedia.org/wiki/Gigabyte">GB</a> (vs <a href="https://en.wikipedia.org/wiki/Gibibyte">GiB</a>). This will correspond to the memory amount printed on the bottom of your camera, if you haven't made any modification.</td>
				</tr>
				<tr>
					<td><code>cameraModel</code></td>
					<td>string</td>
					<td>constant</td>
					<td>The product the API is running on. This corresponds to the model printed on the bottom of your camera. Example: <code>CR14-1.0</code></td>
				</tr>
				<tr>
					<td><code>cameraSerial</code></td>
					<td>string</td>
					<td>constant</td>
					<td>The serial number of the product the API is running on. This corresponds to the SN printed on the bottom of your camera. Example: <code>00555</code></td>
				</tr>
				<tr>
					<td><code>commonlySupportedResolutions</code></td>
					<td>list</td>
					<td>constant</td>
					<td>
						A list of maps. Each map indicates a preset by specifying <code>hRes</code> (int, px), <code>vRes</code> (int, px), and <code>framerate</code> (decimal, frames per second). Partial example:
						<code class="codeblock">
							[{
								'hRes': 1280, 
								'vRes': 1024, 
								'framerate': 1057.362,
							}, …]
						</code>
					</td>
				</tr>
				<tr>
					<td><code>currentCameraState</code></td>
					<td>enum</td>
					<td>property</td>
					<td>Indicates what the camera is doing. One of <code>normal</code>, <code>saving</code> or <code>recording</code>. When saving (to file), parts of the API may be unresponsive. The main difference between <code>normal</code> and <code>recording</code> is whether the red indicator lights on the chronos are red or not. Some actions, like 'stop recording' or 'stop saving', only make sense in certain states.</td>
				</tr>
				<tr>
					<td><code>currentVideoState</code></td>
					<td>enum</td>
					<td>variable</td>
					<td>Indicates what the video display is showing. One of <code>viewfinder</code> or <code>playback</code>.</colgroup>. In <code>viewfinder</code> mode, the video on the back of the camera is showing what the sensor is seeing. In <code>playback</code> mode, the video is showing footage previously recorded in RAM.</td>
				</tr>
				<tr>
					<td><code>disableOverwritingRingBuffer</code></td>
					<td>boolean</td>
					<td>variable</td>
					<td>In segmented mode, disable overwriting earlier recorded ring buffer segments.</td>
				</tr>
				<tr>
					<td><code>externallyPowered</code></td>
					<td>boolean</td>
					<td>property</td>
					<td>Returns True if the camera is running on mains power. In this mode, the battery will recharge until full.</td>
				</tr>
				<tr>
					<td><a name=focusPeakingColor><code>focusPeakingColor</code></a></td>
					<td>integer</td>
					<td>variable</td>
					<td>
						An integer specifying the colour of focus peaking, one of the available focus aids. Like HTML/CSS, this value is composed of four packed 8-bit channels, representing Red, Green, Blue, and Alpha (strength). In <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a>, this is formatted as 0x<span style="color: #D00F;">RR</span><span style="color: #0B0F;">GG</span><span style="color: #00DF;">BB</span><span style="color: #000F;">AA</span>. For example, <code style="color: #AA00AAFF;">0xAA00AAFF</code> is maximum-strength purple, because red and blue are both set to AA, and alpha is set to FF. <code style="color: #C1681988;">0xC1681988</code> is half-strength brown.
						<br>
						To turn off/disable focus peaking, set this value to 0.
					</td>
				</tr>
				<tr>
					<td><code>overlayChronosWatermarkColour</code></td>
					<td>integer</td>
					<td>variable</td>
					<td>8 bit per channel RGBA value indicating the colour for the Chronos logo overlay. The watermark is burned into saved video. See <a href="#focusPeakingColor">focusPeakingColor</a> for more information about colour.</td>
				</tr>
				<tr>
					<td><code>overlayChronosWatermarkX</code></td>
					<td>integer</td>
					<td>variable</td>
					<td rowspan=2>The x/y position (horizontal/vertical offset from the top-left corner) of the Chronos watermark.</td>
				</tr>
				<tr>
					<td><code>overlayChronosWatermarkY</code></td>
					<td>integer</td>
					<td>variable</td>
				</tr>
				<tr>
					<td><a name="overlayRGBImage"><code>overlayRGBImage</code></a></td>
					<td>binary</td>
					<td>variable</td>
					<td>An image to burn on to the video. <a href="https://en.wikipedia.org/wiki/Indexed_color">Indexed colour</a> (like a gif), 20480 pixels maximum. Dimensions are given by the <a href="#overlayRGBImageHeight">overlayRGBImageHeight</a> and <a href="#overlayRGBImageWidth">overlayRGBImageWidth</a> variables. Colour index is given by <a href="#overlayRGBLogoPalette">overlayRGBLogoPalette</a>.</td>
				</td>
				<tr>
					<td><a name="#overlayRGBImageHeight"><code>overlayRGBImageHeight</code></a></td>
					<td>integer</td>
					<td>variable</td>
					<td rowspan=2>Set the width and the height of the <a href="#overlayRGBImage">overlay image/watermark</a> to burn into the video. Area (overlayRGBImageWidth × overlayRGBImageHeight) should be less than 20480.</td>
				</td>
				<tr>
					<td><a name="#overlayRGBImageWidth"><code>overlayRGBImageWidth</code></a></td>
					<td>integer</td>
					<td>variable</td>
				</td>
				<tr>
					<td><code>overlayRGBImageX</code></td>
					<td>integer</td>
					<td>variable</td>
					<td rowspan=2>Set the offset left and top of the <a href="#overlayRGBImage">overlay/watermark image</a>.</td>
				</td>
				<tr>
					<td><code>overlayRGBImageY</code></td>
					<td>integer</td>
					<td>variable</td>
				</td>
				<tr>
					<td><code>overlayRGBLogoPalette</code></td>
					<td>binary</td>
					<td>variable</td>
					<td>
						The colour index for the <a href="#overlayRGBImage">indexed overlay image</a>. Planar format, 256 8-bit bytes each for Red, Green, and Blue. (If you had two colours in your overlay image, pink and black, your colour index might look like:
						<code class=codeblock>
							[
								0xFF, 0x00, «254 more entries»,
								0x00, 0x00, «254 more entries»,
								0xFF, 0x00, «254 more entries»
							]
						</code>
						The first column represents the first colour, pink, with it's red and blue components. The second column represents black.
						<br>
						True black is rendered transparent. If you want to actually draw black, the colour <code style="color: #000001;">0x000001</code> may be used instead of <code style="color: #000000;">0x000000</code>.
					</td>
				</td>
				<tr>
					<td><code>overlayTextbox0Colour</code></td>
					<td>integer</td>
					<td>variable</td>
					<td rowspan=2>Set the textbox's background colour. (Text is always white.) Format RGBA. See <a href="#focusPeakingColor">focusPeakingColor</a> for more information about colour.</td>
				</td>
				<tr>
					<td><code>overlayTextbox1Colour</code></td>
					<td>integer</td>
					<td>variable</td>
				</td>
				<tr>
					<td><a name="overlayTextbox0Content"><code>overlayTextbox0Content</code></a></td>
					<td>string</td>
					<td>variable</td>
					<td rowspan=2>A string of length no more than 128, including a required null terminator (0). Characters in this string are simple numeric indexes into the <a href="#overlayTextbox0Font">overlayTextboxFonts</a>, instead of into the standard <a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters">Unicode</a> (utf-8) tables used elsewhere in this API.</td>
				</td>
				<tr>
					<td><code>overlayTextbox1Content</code></td>
					<td>string</td>
					<td>variable</td>
				</td>
				<tr>
					<td><a name="overlayTextbox0Font"><code>overlayTextbox0Font</code></a></td>
					<td>binary</td>
					<td>variable</td>
					<td rowspan=2>A block of 128 16x32px characters indexed in to by <a href="#overlayTextbox0Content">overlayTextBoxContents</a>. 1<a href="https://en.wikipedia.org/wiki/Color_depth">bpp</a>.</td>
				</td>
				<tr>
					<td><code>overlayTextbox1Font</code></td>
					<td>binary</td>
					<td>variable</td>
				</td>
				<tr>
					<td><code>overlayTextbox0W</code></td>
					<td>integer</td>
					<td>variable</td>
					<td rowspan=4>Textbox dimensions, <strong>w</strong>idth and <strong>h</strong>eight in pixels. Text is centered inside the box.</td>
				</td>
				<tr>
					<td><code>overlayTextbox0H</code></td>
					<td>integer</td>
					<td>variable</td>
				</td>
				<tr>
					<td><code>overlayTextbox1W</code></td>
					<td>integer</td>
					<td>variable</td>
				</td>
				<tr>
					<td><code>overlayTextbox1H</code></td>
					<td>integer</td>
					<td>variable</td>
				</td>
				<tr>
					<td><code>overlayTextbox0OffsetX</code></td>
					<td>integer</td>
					<td>variable</td>
					<td rowspan=4>Distance from the top (y) left (x) corner of the recorded picture to the top left corner of the textbox in pixels.</td>
				</td>
				<tr>
					<td><code>overlayTextbox0OffsetY</code></td>
					<td>integer</td>
					<td>variable</td>
				</td>
				<tr>
					<td><code>overlayTextbox1OffsetX</code></td>
					<td>integer</td>
					<td>variable</td>
				</td>
				<tr>
					<td><code>overlayTextbox1OffsetY</code></td>
					<td>integer</td>
					<td>variable</td>
				</td>
				<tr>
					<td><code>overlayTextbox0X</code></td>
					<td></td>
					<td></td>
					<td rowspan=2></td>
				</td>
				<tr>
					<td><code>overlayTextbox1X</code></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>overlayTextbox0Y</code></td>
					<td></td>
					<td></td>
					<td rowspan=2></td>
				</td>
				<tr>
					<td><code>overlayTextbox1Y</code></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>overlayVersion</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordedSegments</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingAnalogGain</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingExposureNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingHRes</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingHoffset</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingPeriodNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingVRes</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>recordingVoffset</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorFramerateMax</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorHIncrement</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorHMax</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorHMin</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorMaxExposureNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorMaxShutterAngle</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorMinExposureNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorName</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorPixelFormat</code></td>
					<td>string</td>
					<td>constant</td>
					<td>Either <code>BYR2</code> for colour cameras or <code>y12</code> for monochromatic cameras. This corresponds to the Color or Mono information printed on the bottom of the Chronos.</td>
				</td>
				<tr>
					<td><code>sensorPixelRate</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorQuantizeTimingNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorVIncrement</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorVMax</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>sensorVMin</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingExposureDelayNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingMaxExposureNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingMaxPeriod</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingMaxShutterAngle</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingMinExposureNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingMinPeriod</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>timingQuantization</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>triggerCapabilities</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>triggerConfiguration</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>triggerDelayNs</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>triggerState</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>triggers</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>whiteBalance</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
				<tr>
					<td><code>zebraStripesEnabled</code></td>
					<td></td>
					<td></td>
					<td></td>
				</td>
			</tbody>
		</table>
		
		<p>Some settings related to the video pipeline take a little while to update, so it's recommended to set them all at once with one call to to <code>set</code>.</p>
		
		
		<h3>Reference Client</h3>
		
		<p>A Python reference client for the control API is available. If you're using Python to script, it may be useful as a library. Otherwise, it may serve as a useful example how to connect to and use the D-Bus API.</p>
		
		<p>It is <strong>not</strong> required to use the reference client. The client simply sands down some of the rough edges of the D-Bus API. For example, when <code>get</code>ting or <code>set</code>ting a single value, the reference client automatically converts the single value into the list the D-Bus API requires. It also emits an update signal immediately on subscription, which eliminates the need for separate initialiser code in many cases.</p>
		
		<p>The reference API has the following available methods:</p>
		
		<ul>
			<li><code><strong>video</strong>(methodName: string, optional args: any)</code> — Convenience method to invoke one of the D-Bus API Video methods. See the <a href="https://github.com/krontech/chronos-cli/blob/master/src/pipeline/README.md">video api documentation</a> for details.</li>
			<li><code><strong>control</strong>(methodName: string, optional args: any)</code> — </li>
			<li><code><strong>get</strong>(string or [strings])</code> — Convenience method to invoke one of the D-Bus API Video methods. See the <a href="#control-settings">control settings keys</a> for a list of values. If a string is passed, this method will automatically wrap it in a list before calling the underlying D-Bus method and unwrap the returned list.</li>
			<li><code><strong>set</strong>({key: value})</code> — Wrapper for <code>control('set', {…})</code>. See the <a href="#control-settings">control settings keys</a> for a list of values.</li>
			<li><code><strong>observe</strong>(valueName: string, callback: Callable[[Any], None])</code> — Invoke the callback with the new value when the value changes. The value is initially presumed to be unknown, and so is considered to change to the current value is when the subscription is started. valueName is one of the <a href="#control-settings">control settings keys</a>.</li>
			<li><code><strong>observe_future_only</strong></code> — Like <code>observe</code>, but the callback is not called on subscription. This is useful for some of the more complex compound values which can arise around sliders and such.</li>
			<li><code><strong>@silenceCallbacks(Qt Widget)</strong></code> — Function decorator for a callback. Before a decorated callback is called, this turns off events for the supplied Qt Widget. For example, on the main screen of the UI, the callback
				<code class="codeblock">
					@pyqtSlot(int)
					@silenceCallbacks('uiExposureSlider')
					def updateExposureNs(self, newExposureNs):
						self.uiExposureSlider.setValue(newExposureNs)
				</code>
			is used by 
				<code class="codeblock">
					api.observe('recordingExposureNs', self.updateExposureNs)
				</code>
			to update the exposure slider when the exposure is changed externally.
			</li>
		</ul>
		
		
		
		<h2><a name="video-api">Video API</a></h2>
		<p>The video interface deals with getting the video data from A to B.</p>
		
		<p>The <a href="https://github.com/krontech/chronos-cli/blob/master/src/pipeline/README.md">full documentation</a> for the video API is available in the <a href="https://github.com/krontech/chronos-cli">chronos-cli repository</a>.</p>
		
		
		
		<h2><a name="user-interface">User Interface</a></h2>
		<p>The user interface, on the screen on the back of the Chronos, uses the D-Bus API to drive the camera and keep itself in sync with the state the camera is in.</p>
		
		<h2><a name="http-interface">HTTP Interface</a></h2>
		<p><em>I have not written this program yet, but what is documented as follows will follow.</em></p>
		<p>The HTTP interface exposes a web API. It also provides web app which uses the web API. The web app can be used from any phone, tablet, or laptop running a modern web browser.</p>
		
		<p>The HTTP interface is very similar to the D-Bus interface. It mostly exposes the same method calls, and provides the same events. However, it also contains an authentication mechanism so other people can't control your camera without your permission. The D-Bus API does not need an authentication mechanism, since anything capable of talking to it is already running on the camera and can do anything the API can do.</p>
		
		
		
		<h2><a name="ych">Your Client Here</a></h2>
		
		<p>So, you have a specialized application you want the camera to perform? Perhaps you just want to lock down the back-of-camera UI? Luckily for you, it is easy to develop your own application to run on the Chronos.</p>
		
		<p>There are two approaches to developing an app. You can write the code on the camera, or you can write the code on a virtual machine and copy it to the camera later. If you want to set up a VM, refer to <a href="../util/chronos debian setup instructions.txt">~util/chronos debian setup instructions.txt</a>. The following instructions assume you have a working development environment, either on the camera or in a virtual machine.</p>
		
		
		<h3>Connecting to the Camera</h3>
		
		<p>Developing directly on your Chronos, via SSH or file upload, is simpler than developing on a virtual machine. If you develop via SSH, you'll usually run commands and edit files in-place on the camera with Vim or Emacs. If you prefer file upload, you'll set up a little watcher-script that will restart your application when you change a file. The advantage of uploading the files is being able to edit them locally, with your preferred text editor, although this method is a little more complex. Either way the files on the camera are changed, the result is the same.</p>
		
		<p>Before making any changes to your camera, it is strongly recommended to make a backup of your system SD card. Pop the SD card out of the bottom of the camera, insert it into your computer, and then make a backup of the card filesystems. (Not the files themselves.) On Linux, this can be done with <code>gzip /dev/sdb --to-stdout --verbose > chronos-fs-$(date +%F).gz</code>, where <code>/dev/sdb</code> is the device you just plugged in. You can list plugged-in devices with <code>lsblk</code>. (You should see <code>BOOT</code> and <code>ROOTFS</code> on your microSD card.) After you've taken your backup, which will take a while to complete, test it by restoring it to a <em>different</em> microSD card. If you don't have a spare card to test with, it is advised to say a brief prayer instead.</p>
		
		<p>You can connect via the local network by plugging an Ethernet cable into your camera, or connect directly to your computer with a MicroUSB cable. Either way, the camera will get an IP address which you can SSH to. For example, I have my camera connected to my PC via USB, so I run <code>ssh root@192.168.12.1</code> to connect to my camera. I can also visit <code>fish://root@192.168.12.1/root/</code> in Dolphin to browse the files on my camera graphically. When prompted, the password is "chronos", or whatever you set it to.</p>
		
		<p>The camera runs Debian 7 (Wheezy). As such, most common linuxisims will still work, but modern programs must be compiled from scratch. The back-of-camera UI, chronos-gui-2, lives in <code>~/gui</code>. For your own app, you may wish to build new screens for chronos-gui-2, or use it as a reference for developing your own Qt app. The D-Bus API resides in <code>~/chronos-cli</code>. All software running on the CPU is open source, and can be <a href="https://github.com/krontech">freely downloaded from GitHub</a>. If you'd like to contribute a bug fix or a new feature to the existing app, please drop us a line on the forum so we can coordinate!</p>
		
		<p>So, basically, make a new <code>my_client_app.py</code> file on the camera and run it with <code>python3 my_client_app.py</code>. Refer to above for how to make it do stuff.</p>
	</body>
</html>