<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Chronos D-Bus API Documentation</title>
		
		<style>
			/* from http://bettermotherfuckingwebsite.com */
			body {
				margin:40px auto;
				max-width: 650px;
				line-height: 1.6;
				font-size: 18px;
				color: #444;
				padding: 0 10px;
				tab-size: 4;
			}
			
			h1,h2,h3 {
				line-height: 1.2;
			}
			
			
			
			body > code, .codeblock {
				white-space: pre;
				overflow-x: auto;
				display: block;
			}
			
			svg path {
				stroke: black;
			}
			
			svg text {
				font-size: 16px;
				line-height: 1.25;
				text-align: center;
				text-anchor: middle;
				pointer-events: none; /* Keep links, on rects, working when mouse is over text. */
			}
			
			svg rect {
				fill-opacity:.25;
				fill:#10bfbf;
				stroke:#107f7f
			}
		</style>
		
		<script>
			//Remove HTML-formatting whitespace from code snippets. (Leading newlines, indentation.)
			document.addEventListener('DOMContentLoaded', ()=>{
				document.querySelectorAll('code').forEach(elem => {
					lines = elem.innerHTML
						.split('\n')
						.filter(line=>line) //Filter to remove non-code lines, mainly the leading newline between <code> and the actual code.
					
					minLeadingTabs = lines
						.filter(line => line.trim())
						.reduce((minimum, line) => Math.min(line.split(/[^\t]/)[0].length, minimum), Infinity)
					
					elem.innerHTML = lines
						.map(line => line.replace(new RegExp(`^\t{0,${minLeadingTabs}}`), '')) //Remove leading snippet-level indentation, it provides nothing.
						.join('\n')
				})
			})
		</script>
	</head>
	<body>
		<h1>Chronos D-Bus API</h1>
		
		
		
		<p>This documentation covers the Chronos 1.4 <a href="https://www.freedesktop.org/wiki/Software/dbus/">D-Bus</a> API. The API has two major components: The Control API and the Video API. There is also a reference client written in Python which is used for the user interface.</p>
		
		<p>You can use the D-Bus API to write your own application on the camera. This application will be able to display a UI on the back of the camera as well as respond to remote HTTP requests over MiniUSB and the network.</p>
		
		<p>If you only need to control the camera remotely, you should consider using the [planned, as of writing] HTTP interface instead. The HTTP interface lets you send commands to the camera over the network, and is used by the [planned, as of writing] remote-control app. It is easier to develop for the HTTP interface than the D-Bus interface.</p>
		
		
		<h2>Architecture</h2>
		
		<p>The D-Bus APIs sit between the hardware and the applications running on the camera.</p>
		
		<svg id="SVGRoot" version="1.1" viewBox="0 0 701 241" xmlns="http://www.w3.org/2000/svg">
			<g id="layer1" transform="translate(-29.5,-119.5)" inkscape:groupmode="layer" inkscape:label="Layer 1" style="font-family:sans-serif;">
				<a href="#hardware"><rect id="rect2667" x="40" y="160" width="160" height="140"/></a>
				<a href="#control-api"><rect id="rect2669" x="300" y="160" width="160" height="60"/></a>
				<a href="https://github.com/krontech/chronos-cli/blob/master/src/pipeline/README.md"><rect id="rect2671" x="300" y="240" width="160" height="60"/></a>
				<a href="#user-interface"><rect id="rect2673" x="580" y="130" width="140" height="60"/></a>
				<a href="#http-interface"><rect id="rect2675" x="580" y="210" width="140" height="60"/></a>
				<a href="#ych"><rect id="rect2677" x="580" y="290" width="140" height="60" style="fill-opacity:1;fill:#6ecff0;stroke:#2c4d8e"/></a>
				<text id="text3352" x="120.00391" y="225.96484">
					<tspan id="tspan3350" x="120.00391" y="225.96484">Chronos 1.4</tspan><tspan id="tspan3354" x="120.00391" y="245.96484">Hardware</tspan>
				</text>
				<text id="text3358" x="380.33594" y="195.96484">
					<tspan id="tspan3356" x="380.33594" y="195.96484">Control API</tspan>
				</text>
				<text id="text3362" x="380.72266" y="275.96484">
					<tspan id="tspan3360" x="380.72266" y="275.96484">Video API</tspan>
				</text>
				<text id="text3366" x="650.00391" y="154.41406">
					<tspan id="tspan3364" x="650.00391" y="154.41406">User Interface</tspan><tspan id="tspan3368" x="650.00391" y="174.41406">(chronos-gui-2)</tspan>
				</text>
				<text id="text3367" x="649.64062" y="234.41406">
					<tspan id="tspan3364-3" x="649.64062" y="234.41406">HTTP Interface</tspan>
					<tspan id="tspan3368-9" x="649.64062" y="254.41406">(planned)</tspan>
				</text>
				<text id="text3348" x="650.44141" y="325.96484" style="fill:#2c4d8e">
					<tspan id="tspan3346" x="650.44141" y="325.96484">Your Client Here</tspan>
				</text>
				<path id="path3393" d="m300 257.69-100-15.385" inkscape:connection-end="#rect2667" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3397" d="m460 180.31 120 37.698" inkscape:connection-end="#rect2675" inkscape:connection-start="#rect2669" inkscape:connector-type="polyline"/>
				<path id="path3401" d="m452.32 240 127.68-52.963" inkscape:connection-end="#rect2673" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3403" d="m460 260.52 120-14.222" inkscape:connection-end="#rect2675" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3405" d="m460 284.22 120 21.333" inkscape:connection-end="#rect2677" inkscape:connection-start="#rect2671" inkscape:connector-type="polyline"/>
				<path id="path3409" d="m580 167.78-120 13.333" inkscape:connection-end="#rect2669" inkscape:connection-start="#rect2673" inkscape:connector-type="polyline"/>
				<path id="path3411" d="m587.69 290-145.38-70" inkscape:connection-end="#rect2669" inkscape:connection-start="#rect2677" inkscape:connector-type="polyline"/>
				<path id="path3417" d="m200 217.69 100-15.385" inkscape:connection-end="#rect2669" inkscape:connection-start="#rect2667" inkscape:connector-type="polyline"/>
			</g>
		</svg>
		
		<p>The APIs provide a way to configure the camera hardware. The APIs also emit updates so that clients can keep themselves up-to-date when the camera is reconfigured. For example, if the HTTP interface receives a request to change the exposure time of the camera, then the user interface on the camera will need to update itself to reflect the new exposure time.</p>
		
		
		<a name="hardware"><h2>Hardware</h2></a>
		
		<p>The APIs primarily drive the FPGA of the Chronos, as well as set up the video pipeline to display and save content. While the FPGA image itself is proprietary, the register definitions are available as part of the implementation of the APIs.</p>
		
		
		<a name="control-api"><h2>Control API</h2></a>
		
		<p>The control D-Bus API deals with configuring the camera, as opposed to the video API which is responsible for playing back and saving footage.</p>
		
		<h3>Connecting</h3>
		
		<p>To connect to the control API, connect to the D-Bus service/path/interface as in the following example:</p>
		
		<code>
			from PyQt5.QtDBus import QDBusInterface, QDBusConnection
			
			cameraControlAPI = QDBusInterface(
				'com.krontech.chronos.control', #Service
				'/', #Path
				'', #Interface
				QDBusConnection.systemBus() )
		</code>
		
		<p>To use the mock interface, to avoid misconfiguring the camera during development, connect to the <code>com.krontech.chronos.control<strong>.mock</strong></code> service instead of <code>com.krontech.chronos.control</code>.</p>
		
		<h3>Methods</h3>
		
		<ul>
			<li><code><strong>get</strong>([string, string, …])→{string:value, string:value, …}</code> — Return camera setting values. See <a href="#control-settings">Settings</a> for a list of valid keys.</li>
			<li><code><strong>set</strong>({string:value, string:value, …})</code> — Update a camera setting value. See <a href="#control-settings">Settings</a> for a list of valid keys.</li>
			<li><code><strong>available_keys</strong> → [string, string, …]</code> — Get a list of available camera settings keys, for use with <code>get</code> or <code>set</code>.</li>
			<li><code><strong>framerate_for_resolution</strong>(hRes: int, vRes: int) → float</code> — Returns the frames per seconds a resolution will record at. Non-valid resolutions will return undefined results.</li>
			<li><code><strong>resolution_is_valid</strong>(hOffset: int, vOffset: int, hRes: int, vRes: int) → bool</code> — Returns true if the supplied video resolution and offset is valid for recording. A resolution is not valid if it is offset too far. All parameters are positive integers.</li>
			<li><code><strong>power_down</strong></code> — Turn off the camera. Useful in conjunction with the "Turn camera on when power connected" checkbox in the Battery & Power screen.</li>
		</ul>
		
		<p>In addition, when a camera setting is changed, a signal named the key is emitted on the D-Bus interface. It can be intercepted with <code>QDBusConnection.systemBus().connect('com.krontech.chronos.control.mock', '/', '', NAME_OF_KEY, CALLBACK)</code>.
		
		
		<a name="control-settings"><h3>Settings Keys</h3></a>
		
		<p>Control settings keys hold the state of the camera. These keys are used with the <code>get</code> and <code>set</code> method calls. They can be retrieved with the <code>available_keys</code> method.</p>
		
		<p>Keys have different levels of mutability. <strong>Constant</strong> keys do not change over the course of a connection, although they may be changed if the camera is upgraded. These are things like firmware version and the amount of RAM installed. Keys which are a <strong>property</strong>, on the other hand, only change in response to external stimulus. Properties can't be set through the API. These are things like battery level and trigger status. <strong>Variable</strong> keys are settable through the API, but may be changed externally as well.</p>
		
		<ul>
			<li><code><strong>batteryCharge</strong></code> — Decimal property between 0.0 and 1.0 indicating how charged the battery is. 0 is dead, 1 is fully powered.</li>
			<li><code><strong>batteryVoltage</strong></code> — Decimal property indicating voltage of the battery in volts. A happy battery outputs between 12v and 12.5v.</li>
			<li><code><strong>cameraApiVersion</strong></code> — Constant string indicating the iteration of this interface. Adheres to <a href="https://semver.org/">SemVer</a>.</li>
			<li><code><strong>cameraFpgaVersion</strong></code> — Constant string indicating what firmware the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">field-programmable gate array</a> inside the Chronos is running. The FPGA is primarily responsible for recording the high-speed video coming off the sensor to a buffer in RAM.</li>
			<li><code><strong>cameraMemoryGB</strong></code> — Constant decimal. Amount of RAM installed in the Chronos in <a href="https://en.wikipedia.org/wiki/Gigabyte">GB</a> (vs <a href="https://en.wikipedia.org/wiki/Gibibyte">GiB</a>).</li>
			<li><code><strong>cameraModel</strong></code> — </li>
			<li><code><strong>cameraSerial</strong></code> — </li>
			<li><code><strong>commonlySupportedResolutions</strong></code> — </li>
			<li><code><strong>connectionTime</strong></code> — </li>
			<li><code><strong>currentCameraState</strong></code> — </li>
			<li><code><strong>currentVideoState</strong></code> — </li>
			<li><code><strong>disableRingBuffer</strong></code> — </li>
			<li><code><strong>externallyPowered</strong></code> — </li>
			<li><code><strong>focusPeakingColor</strong></code> — </li>
			<li><code><strong>focusPeakingIntensity</strong></code> — </li>
			<li><code><strong>overlayChronosWatermarkColour</strong></code> — </code></li>
			<li><code><strong>overlayChronosWatermarkX</strong></code> — </li>
			<li><code><strong>overlayChronosWatermarkY</strong></code>— </li>
			<li><code><strong>overlayIdentifier</strong></code> — </li>
			<li><code><strong>overlayRGBImage</strong></code> — </li>
			<li><code><strong>overlayRGBImageHeight</strong></code> — </li>
			<li><code><strong>overlayRGBImageWidth</strong></code> — </li>
			<li><code><strong>overlayRGBImageX</strong></code> — </li>
			<li><code><strong>overlayRGBImageY</strong></code> — </li>
			<li><code><strong>overlayRGBLogoPalette</strong></code> — </li>
			<li><code><strong>overlayTextbox0Colour</strong></code> — </li>
			<li><code><strong>overlayTextbox0Content</strong></code> — </li>
			<li><code><strong>overlayTextbox0Font</strong></code> — </li>
			<li><code><strong>overlayTextbox0H</strong></code> — </li>
			<li><code><strong>overlayTextbox0OffsetX</strong></code> — </li>
			<li><code><strong>overlayTextbox0OffsetY</strong></code> — </li>
			<li><code><strong>overlayTextbox0W</strong></code> — </li>
			<li><code><strong>overlayTextbox0X</strong></code> — </li>
			<li><code><strong>overlayTextbox0Y</strong></code> — </li>
			<li><code><strong>overlayTextbox1Colour</strong></code> — </li>
			<li><code><strong>overlayTextbox1Content</strong></code> — </li>
			<li><code><strong>overlayTextbox1Font</strong></code> — </li>
			<li><code><strong>overlayTextbox1H</strong></code> — </li>
			<li><code><strong>overlayTextbox1OffsetX</strong></code> — </li>
			<li><code><strong>overlayTextbox1OffsetY</strong></code> — </li>
			<li><code><strong>overlayTextbox1W</strong></code> — </li>
			<li><code><strong>overlayTextbox1X</strong></code> — </li>
			<li><code><strong>overlayTextbox1Y</strong></code> — </li>
			<li><code><strong>overlayVersion</strong></code> — </li>
			<li><code><strong>recordedSegments</strong></code> — </li>
			<li><code><strong>recordingAnalogGain</strong></code> — </li>
			<li><code><strong>recordingExposureNs</strong></code> — </li>
			<li><code><strong>recordingHRes</strong></code> — </li>
			<li><code><strong>recordingHoffset</strong></code> — </li>
			<li><code><strong>recordingPeriodNs</strong></code> — </li>
			<li><code><strong>recordingVRes</strong></code> — </li>
			<li><code><strong>recordingVoffset</strong></code> — </li>
			<li><code><strong>sensorFramerateMax</strong></code> — </li>
			<li><code><strong>sensorHIncrement</strong></code> — </li>
			<li><code><strong>sensorHMax</strong></code> — </li>
			<li><code><strong>sensorHMin</strong></code> — </li>
			<li><code><strong>sensorMaxExposureNs</strong></code> — </li>
			<li><code><strong>sensorMaxShutterAngle</strong></code> — </li>
			<li><code><strong>sensorMinExposureNs</strong></code> — </li>
			<li><code><strong>sensorName</strong></code> — </li>
			<li><code><strong>sensorPixelFormat</strong></code> — </li>
			<li><code><strong>sensorPixelRate</strong></code> — </li>
			<li><code><strong>sensorQuantizeTimingNs</strong></code> — </li>
			<li><code><strong>sensorVIncrement</strong></code> — </li>
			<li><code><strong>sensorVMax</strong></code> — </li>
			<li><code><strong>sensorVMin</strong></code> — </li>
			<li><code><strong>timingExposureDelayNs</strong></code> — </li>
			<li><code><strong>timingMaxExposureNs</strong></code> — </li>
			<li><code><strong>timingMaxPeriod</strong></code> — </li>
			<li><code><strong>timingMaxShutterAngle</strong></code> — </li>
			<li><code><strong>timingMinExposureNs</strong></code> — </li>
			<li><code><strong>timingMinPeriod</strong></code> — </li>
			<li><code><strong>timingQuantization</strong></code> — </li>
			<li><code><strong>triggerCapabilities</strong></code> — </li>
			<li><code><strong>triggerConfiguration</strong></code> — </li>
			<li><code><strong>triggerDelayNs</strong></code> — </li>
			<li><code><strong>triggerState</strong></code> — </li>
			<li><code><strong>triggers</strong></code> — </li>
			<li><code><strong>whiteBalance</strong></code> — </li>
			<li><code><strong>zebraStripesEnabled</strong></code> — </li>
		</ul>
		
		<p>Some settings related to the video pipeline take a little while to update, so it's recommended to set them all at once with one call to to <code>set</code>.</p>
		
		
		<h3>Reference Client</h3>
		
		<p>A Python reference client for the control API is available. If you're using Python to script, it may be useful as a library. Otherwise, it may serve as a useful example how to connect to and use the D-Bus API.</p>
		
		<p>It is <strong>not</strong> required to use the reference client. The client simply sands down some of the rough edges of the D-Bus API. For example, when <code>get</code>ting or <code>set</code>ting a single value, the reference client automatically converts the single value into the list the D-Bus API requires. It also emits an update signal immediately on subscription, which eliminates the need for separate initialiser code in many cases.</p>
		
		<p>The reference API has the following available methods:</p>
		
		<ul>
			<li><code><strong>video</strong>(methodName: string, optional args: any)</code> — Convenience method to invoke one of the D-Bus API Video methods. See the <a href="https://github.com/krontech/chronos-cli/blob/master/src/pipeline/README.md">video api documentation</a> for details.</li>
			<li><code><strong>control</strong>(methodName: string, optional args: any)</code> — </li>
			<li><code><strong>get</strong>(string or [strings])</code> — Convenience method to invoke one of the D-Bus API Video methods. See the <a href="#control-settings">control settings keys</a> for a list of values. If a string is passed, this method will automatically wrap it in a list before calling the underlying D-Bus method and unwrap the returned list.</li>
			<li><code><strong>set</strong>({key: value})</code> — Wrapper for <code>control('set', {…})</code>. See the <a href="#control-settings">control settings keys</a> for a list of values.</li>
			<li><code><strong>observe</strong>(valueName: string, callback: Callable[[Any], None])</code> — Invoke the callback with the new value when the value changes. The value is initially presumed to be unknown, and so is considered to change to the current value is when the subscription is started. valueName is one of the <a href="#control-settings">control settings keys</a>.</li>
			<li><code><strong>observe_future_only</strong></code> — Like <code>observe</code>, but the callback is not called on subscription. This is useful for some of the more complex compound values which can arise around sliders and such.</li>
			<li><code><strong>@silenceCallbacks(Qt Widget)</strong></code> — Function decorator for a callback. Before a decorated callback is called, this turns off events for the supplied Qt Widget. For example, on the main screen of the UI, the callback
				<code class="codeblock">
					@pyqtSlot(int)
					@silenceCallbacks('uiExposureSlider')
					def updateExposureNs(self, newExposureNs):
						self.uiExposureSlider.setValue(newExposureNs)
				</code>
			is used by 
				<code class="codeblock">
					api.observe('recordingExposureNs', self.updateExposureNs)
				</code>
			to update the exposure slider when the exposure is changed externally.
			</li>
		</ul>
		
		
		
		<a name="video-api"><h2>Video API</h2></a>
		<p>The video interface deals with getting the video data from A to B.</p>
		
		<p>The <a href="https://github.com/krontech/chronos-cli/blob/master/src/pipeline/README.md">full documentation</a> for the video API is available in the <a href="https://github.com/krontech/chronos-cli">chronos-cli repository</a>.</p>
		
		
		
		<a name="user-interface"><h2>User Interface</h2></a>
		<p>The user interface, on the screen on the back of the Chronos, uses the D-Bus API to drive the camera and keep itself in sync with the state the camera is in.</p>
		
		<a name="http-interface"><h2>HTTP Interface</h2></a>
		<p><em>I have not written this program yet, but what is documented as follows will follow.</em></p>
		<p>The HTTP interface exposes a web API. It also provides web app which uses the web API. The web app can be used from any phone, tablet, or laptop running a modern web browser.</p>
		
		<p>The HTTP interface is very similar to the D-Bus interface. It mostly exposes the same method calls, and provides the same events. However, it also contains an authentication mechanism so other people can't control your camera without your permission. The D-Bus API does not need an authentication mechanism, since anything capable of talking to it is already running on the camera and can do anything the API can do.</p>
		
		
		
		<a name="ych"><h2>Your Client Here</h2></a>
		
		<p>So, you have a specialized application you want the camera to perform? Perhaps you just want to lock down the back-of-camera UI? Luckily for you, it is easy to develop your own application to run on the Chronos.</p>
		
		<p>There are two approaches to developing an app. You can write the code on the camera, or you can write the code on a virtual machine and copy it to the camera later. If you want to set up a VM, refer to <a href="../util/chronos debian setup instructions.txt">~util/chronos debian setup instructions.txt</a>. The following instructions assume you have a working development environment, either on the camera or in a virtual machine.</p>
		
		
		<h3>Connecting to the Camera</h3>
		
		<p>Developing directly on your Chronos, via SSH or file upload, is simpler than developing on a virtual machine. If you develop via SSH, you'll usually run commands and edit files in-place on the camera with Vim or Emacs. If you prefer file upload, you'll set up a little watcher-script that will restart your application when you change a file. The advantage of uploading the files is being able to edit them locally, with your preferred text editor, although this method is a little more complex. Either way the files on the camera are changed, the result is the same.</p>
		
		<p>Before making any changes to your camera, it is strongly recommended to make a backup of your system SD card. Pop the SD card out of the bottom of the camera, insert it into your computer, and then make a backup of the card filesystems. (Not the files themselves.) On Linux, this can be done with <code>gzip /dev/sdb --to-stdout --verbose > chronos-fs-$(date +%F).gz</code>, where <code>/dev/sdb</code> is the device you just plugged in. You can list plugged-in devices with <code>lsblk</code>. (You should see <code>BOOT</code> and <code>ROOTFS</code> on your microSD card.) After you've taken your backup, which will take a while to complete, test it by restoring it to a <em>different</em> microSD card. If you don't have a spare card to test with, it is advised to say a brief prayer instead.</p>
		
		<p>You can connect via the local network by plugging an Ethernet cable into your camera, or connect directly to your computer with a MicroUSB cable. Either way, the camera will get an IP address which you can SSH to. For example, I have my camera connected to my PC via USB, so I run <code>ssh root@192.168.12.1</code> to connect to my camera. I can also visit <code>fish://root@192.168.12.1/root/</code> in Dolphin to browse the files on my camera graphically. When prompted, the password is "chronos", or whatever you set it to.</p>
		
		<p>The camera runs Debian 7 (Wheezy). As such, most common linuxisims will still work, but modern programs must be compiled from scratch. The back-of-camera UI, chronos-gui-2, lives in <code>~/gui</code>. For your own app, you may wish to build new screens for chronos-gui-2, or use it as a reference for developing your own Qt app. The D-Bus API resides in <code>~/chronos-cli</code>. All software running on the CPU is open source, and can be <a href="https://github.com/krontech">freely downloaded from GitHub</a>. If you'd like to contribute a bug fix or a new feature to the existing app, please drop us a line on the forum so we can coordinate!</p>
		
		<p>So, basically, make a new <code>my_client_app.py</code> file on the camera and run it with <code>python3 my_client_app.py</code>. Refer to above for how to make it do stuff.</p>
	</body>
</html>