

#Register definitions from control register verilog file (in 16 bit word addresses)
SENSOR_CONTROL				=	0
SENSOR_CLK_PHASE			=	2
SENSOR_SYNC_TOKEN			=	4
SENSOR_DATA_CORRECT			=	6
SENSOR_FIFO_START_W_THRESH	=	8
SENSOR_FIFO_STOP_W_THRESH	=	10
IMAGER_FRAME_PERIOD			=	14
IMAGER_INT_TIME				=	16
SENSOR_SCI_CONTROL			=	18
SENSOR_SCI_ADDRESS			=	20
SENSOR_SCI_DATALEN			=	22
SENSOR_SCI_FIFO_WR_ADDR		=	24
SENSOR_SCI_READ_DATA		=	26

SEQ_CTL						=	32
SEQ_STATUS					=	34
SEQ_FRAME_SIZE				=	36
SEQ_REC_REGION_START		=	38
SEQ_REC_REGION_END			=	40
SEQ_LIVE_ADDR_0				=	42
SEQ_LIVE_ADDR_1				=	44
SEQ_LIVE_ADDR_2				=	46
SEQ_TRIG_DELAY				=	48
SEQ_MD_FIFO_READ			=	50

SENSOR_MAGIC_START_DELAY	=	52
SENSOR_LINE_PERIOD			=	54

TRIG_ENABLE					=	0x50
TRIG_INVERT					=	0x52
TRIG_DEBOUNCE				=	0x54

IO_OUT_LEVEL				=	0x56
IO_OUT_SOURCE				=	0x58
IO_OUT_INVERT				=	0x5A
IO_IN						=	0x5C
EXT_SHUTTER_CTL				=	0x5E

SEQ_PGM_MEM_START			=	0x80
GPMC_PAGE_OFFSET			=	0x100

DISPLAY_CTL					=	0x200
DISPLAY_FRAME_ADDRESS		=	0x202
DISPLAY_FPN_ADDRESS			=	0x204
DISPLAY_GAIN				=	0x206
DISPLAY_H_PERIOD			=	0x208
DISPLAY_V_PERIOD			=	0x20A
DISPLAY_H_SYNC_LEN			=	0x20C
DISPLAY_V_SYNC_LEN			=	0x20E
DISPLAY_H_BACK_PORCH		=	0x210
DISPLAY_V_BACK_PORCH		=	0x212
DISPLAY_H_RES				=	0x214
DISPLAY_V_RES				=	0x216
DISPLAY_H_OUT_RES			=	0x218
DISPLAY_V_OUT_RES			=	0x220
DISPLAY_PEAKING_THRESH		=	0x222
DISPLAY_PIPELINE            =	0x224
DISPLAY_MANUAL_SYNC         =	0x228

CCM_11						=	0x260
CCM_12						=	0x262
CCM_13						=	0x264
CCM_21						=	0x268
CCM_22						=	0x26A
CCM_23						=	0x26C
CCM_31						=	0x26E
CCM_32						=	0x270
CCM_33						=	0x272
WL_DYNDLY_0					=	0x274
WL_DYNDLY_1					=	0x276
WL_DYNDLY_2					=	0x278
WL_DYNDLY_3					=	0x27A

MMU_CONFIG_ADDRESS          =	0x290

SYSTEM_RESET				=	0x300
FPGA_VERSION				=	0x302
FPGA_SUBVERSION             =	0x304
DCG_MEM_START				=	0x800



                                      
#Image sensor control register
IMAGE_SENSOR_CONTROL_ADDR		=	0

IMAGE_SENSOR_RESET_MASK			=	0x1
IMAGE_SENSOR_EVEN_TIMESLOT_MASK =	0x2

#Phase control register

IMAGE_SENSOR_CLK_PHASE_ADDR		=	(SENSOR_CLK_PHASE * 2)
IMAGE_SENSOR_CLK_PHASE_OFFSET	=	0

#Sync Token Register
IMAGE_SENSOR_SYNC_TOKEN_ADDR	=	(SENSOR_SYNC_TOKEN * 2)

#Data Correct
#Indicates data channels 11:0 and sync are correct
# Format: data[11], data[10], ... data[0], sync

IMAGE_SENSOR_DATA_CORRECT_ADDR	=	(SENSOR_DATA_CORRECT * 2)

#Image data write path FIFO thresholds for start and stop of data write to ram

IMAGE_SENSOR_FIFO_START_W_THRESH_ADDR	=	(SENSOR_FIFO_START_W_THRESH	* 2)
IMAGE_SENSOR_FIFO_STOP_W_THRESH_ADDR	=	(SENSOR_FIFO_STOP_W_THRESH * 2)

IMAGER_FRAME_PERIOD_ADDR			=	(IMAGER_FRAME_PERIOD * 2)
IMAGER_INT_TIME_ADDR				=	(IMAGER_INT_TIME * 2)

SENSOR_SCI_CONTROL_ADDR				=	(SENSOR_SCI_CONTROL * 2)
SENSOR_SCI_CONTROL_RUN_MASK			=	0x1						#Write 1 to start, reads 1 while busy, 0 when done
SENSOR_SCI_CONTROL_RW_MASK			=	0x2						#Read == 1, Write == 0
SENSOR_SCI_CONTROL_FIFO_FULL_MASK	=	0x4					#1 indicates FIFO is full
SENSOR_SCI_ADDRESS_ADDR				=	(SENSOR_SCI_ADDRESS * 2)
SENSOR_SCI_DATALEN_ADDR				=	(SENSOR_SCI_DATALEN * 2)
SENSOR_SCI_FIFO_WR_ADDR_ADDR		=	(SENSOR_SCI_FIFO_WR_ADDR * 2)
SENSOR_SCI_READ_DATA_ADDR			=	(SENSOR_SCI_READ_DATA * 2)

SEQ_CTL_ADDR					=	(SEQ_CTL * 2)
SEQ_CTL_SW_TRIG_MASK			=	0x1
SEQ_CTL_START_REC_MASK			=	0x2
SEQ_CTL_STOP_REC_MASK			=	0x4
SEQ_CTL_TRIG_DELAY_MODE_MASK	=	0x8

SEQ_STATUS_ADDR					=	(SEQ_STATUS * 2)
SEQ_STATUS_RECORDING_MASK		=	0x1
SEQ_STATUS_MD_FIFO_EMPTY_MASK	=	0x2

SEQ_FRAME_SIZE_ADDR				=	(SEQ_FRAME_SIZE * 2)
SEQ_REC_REGION_START_ADDR		=	(SEQ_REC_REGION_START * 2)
SEQ_REC_REGION_END_ADDR			=	(SEQ_REC_REGION_END * 2)
SEQ_LIVE_ADDR_0_ADDR			=	(SEQ_LIVE_ADDR_0 * 2)
SEQ_LIVE_ADDR_1_ADDR			=	(SEQ_LIVE_ADDR_1 * 2)
SEQ_LIVE_ADDR_2_ADDR			=	(SEQ_LIVE_ADDR_2 * 2)
SEQ_TRIG_DELAY_ADDR				=	(SEQ_TRIG_DELAY * 2)
SEQ_MD_FIFO_READ_ADDR			=	(SEQ_MD_FIFO_READ * 2)
SEQ_PGM_MEM_START_ADDR			=	(SEQ_PGM_MEM_START * 2)

SENSOR_MAGIC_START_DELAY_ADDR	=	(SENSOR_MAGIC_START_DELAY * 2)
SENSOR_LINE_PERIOD_ADDR			=	(SENSOR_LINE_PERIOD * 2)

TRIG_ENABLE_ADDR				=	(TRIG_ENABLE * 2)
TRIG_INVERT_ADDR				=	(TRIG_INVERT * 2)
TRIG_DEBOUNCE_ADDR				=	(TRIG_DEBOUNCE * 2)

IO_OUT_LEVEL_ADDR				=	(IO_OUT_LEVEL * 2)		#1 outputs high if selected (invert does not affect this)
IO_OUT_SOURCE_ADDR				=	(IO_OUT_SOURCE * 2)		#1 selects int time, 0 selects IO_OUT_LEVEL
IO_OUT_INVERT_ADDR				=	(IO_OUT_INVERT * 2)		#1 inverts int time signal
IO_IN_ADDR						=	(IO_IN * 2)		#1 inverts int time signal

EXT_SHUTTER_CTL_ADDR			=	(EXT_SHUTTER_CTL * 2)
EXT_SH_TRIGD_EXP_EN_MASK		=	0x1
EXT_SH_TRIGD_EXP_EN_OFFSET		=	0
EXT_SH_GATING_EN_MASK			=	0x2
EXT_SH_GATING_EN_OFFSET			=	1
EXT_SH_SRC_EN_MASK				=	0x1C
EXT_SH_SRC_EN_OFFSET			=	2

GPMC_PAGE_OFFSET_ADDR			=	(GPMC_PAGE_OFFSET * 2)

DISPLAY_CTL_ADDR				=	(DISPLAY_CTL * 2)
DISPLAY_CTL_ADDRESS_SEL_OFFSET	=	0
DISPLAY_CTL_SCALER_NN_OFFSET	=	1
DISPLAY_CTL_SYNC_INH_OFFSET		=	2
DISPLAY_CTL_READOUT_INH_OFFSET	=	3
DISPLAY_CTL_COLOR_MODE_OFFSET	=	4
DISPLAY_CTL_FOCUS_PEAK_EN_OFFSET	=	5
DISPLAY_CTL_FOCUS_PEAK_COLOR_OFFSET	=	6
DISPLAY_CTL_ZEBRA_EN_OFFSET		=	9

DISPLAY_CTL_ADDRESS_SEL_MASK	=	(1 << DISPLAY_CTL_ADDRESS_SEL_OFFSET)
DISPLAY_CTL_SCALER_NN_MASK		=	(1 << DISPLAY_CTL_SCALER_NN_OFFSET)
DISPLAY_CTL_SYNC_INH_MASK		=	(1 << DISPLAY_CTL_SYNC_INH_OFFSET)
DISPLAY_CTL_READOUT_INH_MASK	=	(1 << DISPLAY_CTL_READOUT_INH_OFFSET)
DISPLAY_CTL_COLOR_MODE_MASK		=	(1 << DISPLAY_CTL_COLOR_MODE_OFFSET)
DISPLAY_CTL_FOCUS_PEAK_EN_MASK	=	(1 << DISPLAY_CTL_FOCUS_PEAK_EN_OFFSET)
DISPLAY_CTL_FOCUS_PEAK_COLOR_MASK	=	(7 << DISPLAY_CTL_FOCUS_PEAK_COLOR_OFFSET)
DISPLAY_CTL_ZEBRA_EN_MASK		=	(1 << DISPLAY_CTL_ZEBRA_EN_OFFSET)

DISPLAY_FRAME_ADDRESS_ADDR		=	(DISPLAY_FRAME_ADDRESS * 2)
DISPLAY_FPN_ADDRESS_ADDR		=	(DISPLAY_FPN_ADDRESS * 2)
DISPLAY_GAIN_ADDR				=	(DISPLAY_GAIN * 2)
DISPLAY_H_PERIOD_ADDR			=	(DISPLAY_H_PERIOD * 2)
DISPLAY_V_PERIOD_ADDR			=	(DISPLAY_V_PERIOD * 2)
DISPLAY_H_SYNC_LEN_ADDR			=	(DISPLAY_H_SYNC_LEN * 2)
DISPLAY_V_SYNC_LEN_ADDR			=	(DISPLAY_V_SYNC_LEN * 2)
DISPLAY_H_BACK_PORCH_ADDR		=	(DISPLAY_H_BACK_PORCH * 2)
DISPLAY_V_BACK_PORCH_ADDR		=	(DISPLAY_V_BACK_PORCH * 2)
DISPLAY_H_RES_ADDR				=	(DISPLAY_H_RES * 2)
DISPLAY_V_RES_ADDR				=	(DISPLAY_V_RES * 2)
DISPLAY_H_OUT_RES_ADDR			=	(DISPLAY_H_OUT_RES * 2)
DISPLAY_V_OUT_RES_ADDR			=	(DISPLAY_V_OUT_RES * 2)
DISPLAY_PEAKING_THRESH_ADDR		=	(DISPLAY_PEAKING_THRESH * 2)

DISPLAY_PIPELINE_ADDR           	=	(DISPLAY_PIPELINE * 2)
DISPLAY_PIPELINE_BIPASS_FPN         =	(1 << 0)
DISPLAY_PIPELINE_BIPASS_GAIN        =	(1 << 1)
DISPLAY_PIPELINE_BIPASS_DEMOSIAC    =	(1 << 2)
DISPLAY_PIPELINE_BIPASS_COLORMATRIX =	(1 << 3)
DISPLAY_PIPELINE_BIPASS_GAMMA_TABLE =	(1 << 4)
DISPLAY_PIPELINE_RAW_12BPP          =	(1 << 5)
DISPLAY_PIPELINE_RAW_16BPP          =	(1 << 6)
DISPLAY_PIPELINE_RAW_RIGHT_JUSTIFY  =	(1 << 7)
DISPLAY_PIPELINE_RAW_TEST_PATTERN   =	(1 << 15)

DISPLAY_MANUAL_SYNC_ADDR        =	(DISPLAY_MANUAL_SYNC * 2)
DISPLAY_MANUAL_SYNC_MASK        =	(1)

CCM_11_ADDR						=	(CCM_11 * 2)
CCM_12_ADDR						=	(CCM_12 * 2)
CCM_13_ADDR						=	(CCM_13 * 2)
CCM_21_ADDR						=	(CCM_21 * 2)
CCM_22_ADDR						=	(CCM_22 * 2)
CCM_23_ADDR						=	(CCM_23 * 2)
CCM_31_ADDR						=	(CCM_31 * 2)
CCM_32_ADDR						=	(CCM_32 * 2)
CCM_33_ADDR						=	(CCM_33 * 2)

WL_DYNDLY_0_ADDR				=	(WL_DYNDLY_0 * 2)
WL_DYNDLY_1_ADDR				=	(WL_DYNDLY_1 * 2)
WL_DYNDLY_2_ADDR				=	(WL_DYNDLY_2 * 2)
WL_DYNDLY_3_ADDR				=	(WL_DYNDLY_3 * 2)

MMU_CONFIG_ADDR                 =	(MMU_CONFIG_ADDRESS * 2)
MMU_INVERT_CS                   =	1
MMU_SWITCH_STUFFED              =	2

SYSTEM_RESET_ADDR				=	(SYSTEM_RESET * 2)

FPGA_VERSION_ADDR				=	(FPGA_VERSION * 2)
FPGA_SUBVERSION_ADDR            =	(FPGA_SUBVERSION * 2)

DCG_MEM_START_ADDR				=	(DCG_MEM_START * 2)



#========================================================================================================
#                                   New format registers

#---------------------------------- Wishbone RAM Access -----------------------------------------


RAM_REG_BASE                =	(0x2000)
RAM_REG_BLOCK               =	(RAM_REG_BASE)

# identifier
RAM_IDENTIFIER_REG          =	(RAM_REG_BLOCK + 0x00)
RAM_VERSION_REG             =	(RAM_REG_BLOCK + 0x04)
RAM_SUBVERSION_REG          =	(RAM_REG_BLOCK + 0x08)

# reset and control
RAM_CONTROL                 =	(RAM_REG_BLOCK + 0x0C)
RAM_STATUS                  =	(RAM_REG_BLOCK + 0x10)

RAM_ADDRESS                 =	(RAM_REG_BLOCK + 0x20) # 32 bit 
RAM_BURST_LENGTH            =	(RAM_REG_BLOCK + 0x24)

# Read/write buffers
RAM_BUFFER_START            =	(RAM_REG_BLOCK + 0x200) # 1024*16bit (64-ram page) 
RAM_BUFFER_END              =	(RAM_REG_BLOCK + 0xA00)



RAM_IDENTIFIER =	(0x0040)

RAM_CONTROL_TRIGGER_READ  =	0x0001
RAM_CONTROL_TRIGGER_WRITE =	0x0002

RAM_BURST_LENGTH_MAX =	32

#------------------------------------------------------------------------------------------------




